// ==== FILE: app\layout.tsx ====
export { default, generateMetadata } from '../src/app/layout'

// ==== FILE: app\loading.tsx ====
import React from 'react'

import { PostCardSkeleton } from '@/components/post-card-skeleton'

export default function RootLoading() {
Â  return (
Â  Â  <div className="container mx-auto px-4 py-12">
Â  Â  Â  <div className="grid gap-6 grid-cols-1 sm:grid-cols-2 lg:grid-cols-3">
Â  Â  Â  Â  {Array.from({ length: 6 }).map((_, i) => (
Â  Â  Â  Â  Â  <PostCardSkeleton key={i} />
Â  Â  Â  Â  ))}
Â  Â  Â  </div>
Â  Â  </div>
Â  )
}

// ==== FILE: app\not-found.tsx ====
import Link from 'next/link'

export default function NotFound() {
Â  return (
Â  Â  <div className="container mx-auto px-4 py-24 text-center">
Â  Â  Â  <h1 className="text-4xl font-bold mb-4">Page not found</h1>
Â  Â  Â  <p className="text-muted-foreground mb-8">The page youâ€™re looking for doesnâ€™t exist.</p>
Â  Â  Â  <Link href="/" className="bg-primary text-primary-foreground px-4 py-2 rounded">Back to Home</Link>
Â  Â  </div>
Â  )
}

// ==== FILE: app\page.tsx ====
export { default } from "../src/app/page";
export * from "../src/app/page";

// ==== FILE: app\about\page.tsx ====
import { Avatar, AvatarImage, AvatarFallback } from "@/components/ui/avatar";

export default function AboutPage() {
Â  return (
Â  Â  <section className="container mx-auto px-4 py-12 max-w-2xl animate-fade-in">
Â  Â  Â  <div className="flex flex-col items-center bg-card/60 rounded-xl shadow-lg p-8 mb-8">
Â  Â  Â  Â  <Avatar className="h-24 w-24 mb-4 ring-4 ring-primary/30">
Â  Â  Â  Â  Â  <AvatarImage src="https://avatars.githubusercontent.com/u/10296482?v=4" alt="Ajay Chaturvedi" />
Â  Â  Â  Â  Â  <AvatarFallback>AC</AvatarFallback>
Â  Â  Â  Â  </Avatar>
Â  Â  Â  Â  <h1 className="text-3xl font-bold mb-1 text-center">Ajay Chaturvedi</h1>
Â  Â  Â  Â  <p className="text-muted-foreground mb-4 text-center">Founder, TechOblivion</p>
Â  Â  Â  Â  <p className="mb-6 text-lg text-center">Iâ€™m Ajay, passionate about technology and problem-solving. Through <span className="font-semibold">TechOblivion</span>, I share my journey, projects, and ideas to inspire and build together.</p>
Â  Â  Â  Â  <div className="flex flex-wrap justify-center gap-3 mb-2">
Â  Â  Â  Â  Â  <a href="https://techoblivion.in/" className="btn-link" target="_blank" rel="noopener noreferrer">ğŸŒ Website</a>
Â  Â  Â  Â  Â  <a href="https://github.com/Ajaykr2109" className="btn-link" target="_blank" rel="noopener noreferrer">GitHub</a>
Â  Â  Â  Â  Â  <a href="https://www.facebook.com/ajaykrchaturvedi/" className="btn-link" target="_blank" rel="noopener noreferrer">Facebook</a>
Â  Â  Â  Â  Â  <a href="https://x.com/ChaturvediKrAj" className="btn-link" target="_blank" rel="noopener noreferrer">X (Twitter)</a>
Â  Â  Â  Â  Â  <a href="https://www.linkedin.com/in/ajaykrchaturvedi/" className="btn-link" target="_blank" rel="noopener noreferrer">LinkedIn</a>
Â  Â  Â  Â  Â  <a href="https://www.youtube.com/@tech.oblivion" className="btn-link" target="_blank" rel="noopener noreferrer">YouTube</a>
Â  Â  Â  Â  </div>
Â  Â  Â  </div>
Â  Â  Â  <div className="bg-muted/40 rounded-lg p-6 shadow-sm">
Â  Â  Â  Â  <h2 className="text-xl font-semibold mb-2">About TechOblivion</h2>
Â  Â  Â  Â  <p className="mb-2">TechOblivion is a platform dedicated to sharing knowledge, projects, and inspiration in technology. Whether youâ€™re a developer, enthusiast, or just curious, youâ€™ll find something to spark your interest.</p>
Â  Â  Â  Â  <ul className="list-disc list-inside text-muted-foreground mb-2">
Â  Â  Â  Â  Â  <li>Project showcases & tutorials</li>
Â  Â  Â  Â  Â  <li>Tech blogs & insights</li>
Â  Â  Â  Â  Â  <li>Community-driven learning</li>
Â  Â  Â  Â  </ul>
Â  Â  Â  Â  <p className="text-sm text-muted-foreground">Â© 2025 Tech Oblivion. All Rights Reserved.</p>
Â  Â  Â  </div>
Â  Â  </section>
Â  );
}

// ==== FILE: app\account\layout.tsx ====
'use client'

import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { User as UserIcon, LayoutDashboard, Shield, Image as ImageIcon, Settings } from 'lucide-react'

import { cn } from '@/lib/utils'

const sidebarNavLinks = [
Â  { href: '/account', label: 'Overview', icon: LayoutDashboard },
Â  { href: '/account/profile', label: 'Profile', icon: UserIcon },
Â  { href: '/account/avatar', label: 'Avatar', icon: ImageIcon },
Â  { href: '/account/security', label: 'Security', icon: Shield },
Â  { href: '/account/settings', label: 'Preferences', icon: Settings },
]

export default function AccountLayout({ children }: { children: React.ReactNode }) {
Â  const pathname = usePathname()

Â  return (
Â  Â  <div className="flex min-h-screen">
Â  Â  Â  <aside className="w-64 flex-shrink-0 border-r bg-card/50 p-4">
Â  Â  Â  Â  <div className="flex h-full flex-col">
Â  Â  Â  Â  Â  <div className="mb-8 flex items-center gap-2 px-2 font-bold">
Â  Â  Â  Â  Â  Â  <Link href="/" className="font-bold">
Â  Â  Â  Â  Â  Â  Â  tech.oblivion
Â  Â  Â  Â  Â  Â  </Link>
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  <nav className="flex flex-col gap-2">
Â  Â  Â  Â  Â  Â  {sidebarNavLinks.map((link) => {
Â  Â  Â  Â  Â  Â  Â  const isActive = pathname === link.href
Â  Â  Â  Â  Â  Â  Â  return (
Â  Â  Â  Â  Â  Â  Â  Â  <Link
Â  Â  Â  Â  Â  Â  Â  Â  Â  key={link.href}
Â  Â  Â  Â  Â  Â  Â  Â  Â  href={link.href}
Â  Â  Â  Â  Â  Â  Â  Â  Â  className={cn(
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'flex items-center gap-3 rounded-md px-3 py-2 text-sm font-medium transition-colors',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isActive
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ? 'bg-primary text-primary-foreground'
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  : 'text-muted-foreground hover:bg-accent hover:text-accent-foreground'
Â  Â  Â  Â  Â  Â  Â  Â  Â  )}
Â  Â  Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  Â  Â  <link.icon className="h-4 w-4" />
Â  Â  Â  Â  Â  Â  Â  Â  Â  <span>{link.label}</span>
Â  Â  Â  Â  Â  Â  Â  Â  </Link>
Â  Â  Â  Â  Â  Â  Â  )
Â  Â  Â  Â  Â  Â  })}
Â  Â  Â  Â  Â  </nav>
Â  Â  Â  Â  </div>
Â  Â  Â  </aside>
Â  Â  Â  <main className="flex-1 overflow-auto bg-background">{children}</main>
Â  Â  </div>
Â  )
}

// ==== FILE: app\account\page.tsx ====
import { redirect } from 'next/navigation'

import { getSessionUser } from '@/lib/auth'

import AccountCentral from '../../src/app/account/page'

export default async function AccountPageWrapper() {
const user = await getSessionUser()
if (!user) redirect('/login?next=/account')
return <AccountCentral />
}

// ==== FILE: app\account\avatar\page.tsx ====
import { redirect } from 'next/navigation'

import { getSessionUser } from '@/lib/auth'

import AccountAvatarPage from '../../../src/app/account/avatar/page'

export default async function AccountAvatarWrapper() {
const user = await getSessionUser()
if (!user) redirect('/login?next=/account/avatar')
return <AccountAvatarPage />
}

// ==== FILE: app\account\profile\page.tsx ====
import { redirect } from 'next/navigation'

import { getSessionUser } from '@/lib/auth'

import AccountProfilePage from '../../../src/app/account/profile/page'

export default async function AccountProfileWrapper() {
const user = await getSessionUser()
if (!user) redirect('/login?next=/account/profile')
return <AccountProfilePage />
}

// ==== FILE: app\account\security\page.tsx ====
export default function SecurityPage() {
Â  return <div className="p-6">Security settings coming soon.</div>
}

// ==== FILE: app\account\settings\page.tsx ====
export default function PreferencesPage() {
Â  return <div className="p-6">Preferences coming soon.</div>
}

// ==== FILE: app\admin\layout.tsx ====

'use client'

import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { LayoutDashboard, FileText, Users, MessageSquare, SettingsIcon, ImageIcon, Tags, FolderCog, PlugIcon, Palette, Activity, TestTubes } from 'lucide-react'
import { motion, AnimatePresence } from 'framer-motion'

import { cn } from '@/lib/utils'
import { ThemeToggle } from '@/components/theme-toggle'
import { useMe } from '@/hooks/useRoleGate'
import { mapToApiRole } from '@/lib/rbac'
import checkAccess from '@/lib/checkAccess'

type IconType = React.ComponentType<React.SVGProps<SVGSVGElement>>
type Item = { href: string; label: string; icon: IconType; key: string }
type Group = { label: string; items: Item[] }

const RAW_GROUPS: Group[] = [
Â  {
Â  Â  label: 'Overview',
Â  Â  items: [
Â  Â  Â  { href: '/admin', label: 'Dashboard', icon: LayoutDashboard, key: 'dashboard' },
Â  Â  Â  { href: '/admin/analytics', label: 'Analytics', icon: Activity, key: 'analytics' },
Â  Â  ],
Â  },
Â  {
Â  Â  label: 'Content',
Â  Â  items: [
Â  Â  Â  { href: '/admin/posts', label: 'Posts', icon: FileText, key: 'posts' },
Â  Â  Â  { href: '/admin/media', label: 'Media', icon: ImageIcon, key: 'media' },
Â  Â  Â  { href: '/admin/categories', label: 'Categories', icon: FolderCog, key: 'categories' },
Â  Â  Â  { href: '/admin/tags', label: 'Tags', icon: Tags, key: 'tags' },
Â  Â  Â  { href: '/admin/comments', label: 'Comments', icon: MessageSquare, key: 'comments' },
Â  Â  ],
Â  },
Â  {
Â  Â  label: 'People',
Â  Â  items: [
Â  Â  Â  { href: '/admin/users', label: 'Users', icon: Users, key: 'users' },
Â  Â  ],
Â  },
Â  {
Â  Â  label: 'System',
Â  Â  items: [
Â  Â  Â  { href: '/admin/settings', label: 'Settings', icon: SettingsIcon, key: 'settings' },
Â  Â  Â  { href: '/admin/plugins', label: 'Plugins', icon: PlugIcon, key: 'plugins' },
Â  Â  Â  { href: '/admin/themes', label: 'Themes', icon: Palette, key: 'themes' },
Â  Â  Â  { href: '/admin/site-health', label: 'Site Health', icon: Activity, key: 'site-health' },
Â  Â  Â  { href: '/admin/debug', label: 'Debug/Test', icon: TestTubes, key: 'debug' },
Â  Â  ],
Â  },
]

// Associate keys with RBAC-capable endpoints for gating
const KEY_TO_ENDPOINT: Record<string, { path: string; method: string; action: 'read' | 'write' | 'delete' | 'moderate' }[]> = {
Â  analytics: [
Â  Â  { path: '/api/analytics/summary', method: 'GET', action: 'read' },
Â  ],
Â  posts: [
Â  Â  { path: '/api/wp/posts', method: 'POST', action: 'write' },
Â  ],
Â  media: [
Â  Â  { path: '/api/wp/media', method: 'POST', action: 'write' },
Â  ],
Â  categories: [
Â  Â  { path: '/api/wp/categories', method: 'POST', action: 'write' },
Â  ],
Â  tags: [
Â  Â  { path: '/api/wp/tags', method: 'POST', action: 'write' },
Â  ],
Â  comments: [
Â  Â  { path: '/api/wp/comments/[id]', method: 'PATCH', action: 'moderate' },
Â  ],
Â  users: [
Â  Â  { path: '/api/wp/users', method: 'GET', action: 'read' },
Â  ],
Â  settings: [
Â  Â  { path: '/api/wp/settings', method: 'GET', action: 'read' },
Â  ],
Â  plugins: [
Â  Â  { path: '/api/wp/plugins', method: 'GET', action: 'read' },
Â  ],
Â  themes: [
Â  Â  { path: '/api/wp/themes', method: 'GET', action: 'read' },
Â  ],
Â  'site-health': [
Â  Â  { path: '/api/wp/site-health/background-updates', method: 'GET', action: 'read' },
Â  ],
Â  debug: [
Â  Â  { path: '/api/_debug', method: 'GET', action: 'read' },
Â  Â  { path: '/api/test', method: 'GET', action: 'read' },
Â  ],
Â  dashboard: [
Â  Â  { path: '/api/admin', method: 'GET', action: 'read' },
Â  ],
}

export default function AdminLayout({
Â  children,
}: {
Â  children: React.ReactNode
}) {
Â  const pathname = usePathname()
Â  const { me } = useMe()
Â  const apiRole = mapToApiRole(me?.roles)

Â  // Build groups filtered by RBAC matrix; also dedupe by key
Â  const filtered: Group[] = RAW_GROUPS.map((g) => {
Â  Â  const uniq = new Map<string, Item>()
Â  Â  for (const it of g.items) {
Â  Â  Â  if (uniq.has(it.key)) continue
Â  Â  Â  const endpoints = KEY_TO_ENDPOINT[it.key] || []
Â  Â  Â  const allowed = endpoints.length === 0 || endpoints.some((e) => checkAccess(apiRole, e.path, e.method, e.action))
Â  Â  Â  if (allowed) uniq.set(it.key, it)
Â  Â  }
Â  Â  return { label: g.label, items: Array.from(uniq.values()) }
Â  }).filter((g) => g.items.length > 0)

Â  return (
Â  Â  <div className="flex min-h-screen">
Â  Â  Â  <aside className="w-64 flex-shrink-0 border-r bg-card/50 p-4">
Â  Â  Â  Â  <div className="flex h-full flex-col">
Â  Â  Â  Â  Â  <div className="mb-8 flex items-center gap-2 px-2 font-bold">
Â  Â  Â  Â  Â  Â  <Link href="/" className="font-bold">
Â  Â  Â  Â  Â  Â  Â  tech.oblivion
Â  Â  Â  Â  Â  Â  </Link>
Â  Â  Â  Â  Â  Â  <div className="ml-auto"><ThemeToggle /></div>
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  <nav className="flex flex-col gap-4">
Â  Â  Â  Â  Â  Â  {filtered.map((group) => (
Â  Â  Â  Â  Â  Â  Â  <div key={group.label}>
Â  Â  Â  Â  Â  Â  Â  Â  <div className="px-3 pb-1 text-xs font-medium uppercase text-muted-foreground">{group.label}</div>
Â  Â  Â  Â  Â  Â  Â  Â  <div className="flex flex-col gap-1">
Â  Â  Â  Â  Â  Â  Â  Â  Â  <AnimatePresence initial={false}>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {group.items.map((link) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const isActive = pathname === link.href
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <motion.div
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  key={link.href}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  initial={{ opacity: 0, y: -4 }}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  animate={{ opacity: 1, y: 0 }}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  exit={{ opacity: 0, y: -4 }}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  transition={{ duration: 0.15 }}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <Link
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  href={link.href}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className={cn(
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'flex items-center gap-3 rounded-md px-3 py-2 text-sm font-medium transition-colors',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isActive
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ? 'bg-primary text-primary-foreground'
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  : 'text-muted-foreground hover:bg-accent hover:text-accent-foreground'
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  )}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <link.icon className="h-4 w-4" />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span>{link.label}</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </Link>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </motion.div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  )
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  })}
Â  Â  Â  Â  Â  Â  Â  Â  Â  </AnimatePresence>
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  ))}
Â  Â  Â  Â  Â  </nav>
Â  Â  Â  Â  </div>
Â  Â  Â  </aside>
Â  Â  Â  <main className="flex-1 overflow-auto bg-background">
Â  Â  Â  Â  {children}
Â  Â  Â  </main>
Â  Â  </div>
Â  )
}

// ==== FILE: app\admin\page.tsx ====
import { redirect } from 'next/navigation'

export const runtime = 'nodejs'

export default function AdminHomePage() {
Â  redirect('/admin/dashboard')
}

// ==== FILE: app\admin\analytics\page.tsx ====
import AdminDashboard from '@/components/admin/AdminDashboard'

export const runtime = 'nodejs'

export default function Page() {
Â  return <AdminDashboard sectionKey="analytics" />
}

// ==== FILE: app\admin\categories\page.tsx ====
import AdminDashboard from '@/components/admin/AdminDashboard'

export const runtime = 'nodejs'

export default function Page() { return <AdminDashboard sectionKey="categories" /> }

// ==== FILE: app\admin\comments\page.tsx ====
import AdminDashboard from '@/components/admin/AdminDashboard'

export const runtime = 'nodejs'

export default function Page() { return <AdminDashboard sectionKey="comments" /> }

// ==== FILE: app\admin\comments\pageClient.tsx ====
"use client"

import { useMemo, useState } from 'react'
import { Reply, Trash2 } from 'lucide-react'

import BulkActionsBar, { BulkAction } from '@/components/admin/BulkActionsBar'
import { TableCell } from '@/components/ui/table'
import SelectableTable from '@/components/admin/SelectableTable'
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar'
import { Button } from '@/components/ui/button'

const dummyComments = [
Â  { id: 1, author: "Alex Johnson", avatar: "https://i.pravatar.cc/150?u=a04258114e29026702d", text: "This was an incredibly insightful article. The section on server components really cleared things up for me. Thanks!", post: "A Deep Dive into React Server Components", date: "2024-07-29" },
Â  { id: 2, author: "Maria Garcia", avatar: "https://i.pravatar.cc/150?u=a042581f4e29026703d", text: "I'm not sure I agree with point number 3. Have you considered the performance implications on larger-scale applications?", post: "The Future of AI in Web Development", date: "2024-07-28" },
Â  { id: 3, author: "Sam Lee", avatar: "https://i.pravatar.cc/150?u=a042581f4e29026704d", text: "Great post! Do you have a GitHub repository with the code examples?", post: "Mastering Tailwind CSS for Modern UIs", date: "2024-07-28" },
]

export default function CommentsClient() {
Â  const [selected, setSelected] = useState<number[]>([])
Â  const header = useMemo(()=>[
Â  Â  'Author', 'Comment', 'Post', 'Date', 'Actions'
Â  ], [])
Â  const rows = useMemo(()=> dummyComments.map(c => ({
Â  Â  id: c.id,
Â  Â  cells: [
Â  Â  Â  <div className="flex items-center gap-3" key="author">
Â  Â  Â  Â  <Avatar>
Â  Â  Â  Â  Â  <AvatarImage src={c.avatar} alt={c.author} />
Â  Â  Â  Â  Â  <AvatarFallback>{c.author.charAt(0)}</AvatarFallback>
Â  Â  Â  Â  </Avatar>
Â  Â  Â  Â  <span className="font-medium">{c.author}</span>
Â  Â  Â  </div>,
Â  Â  Â  <span className="text-muted-foreground" key="text">{c.text}</span>,
Â  Â  Â  <span key="post">{c.post}</span>,
Â  Â  Â  <span key="date">{c.date}</span>,
Â  Â  Â  <div className="flex justify-end gap-2" key="actions">
Â  Â  Â  Â  <Button variant="outline" size="sm"><Reply className="mr-2 h-4 w-4" /> Reply</Button>
Â  Â  Â  Â  <Button variant="destructive" size="sm"><Trash2 className="mr-2 h-4 w-4" /> Delete</Button>
Â  Â  Â  </div>
Â  Â  ]
Â  })), [])

Â  const onAction = async (action: BulkAction) => {
Â  Â  if (selected.length === 0) return
Â  Â  const res = await fetch('/api/wp/comments/bulk', {
Â  Â  Â  method: 'POST',
Â  Â  Â  headers: { 'Content-Type': 'application/json' },
Â  Â  Â  body: JSON.stringify({ ids: selected, action })
Â  Â  })
Â  Â  if (!res.ok) throw new Error('Bulk action failed')
Â  }

Â  return (
Â  Â  <div>
Â  Â  Â  <BulkActionsBar onAction={onAction} disabled={selected.length===0} />
Â  Â  Â  <SelectableTable rows={rows} header={header} onSelectionChange={setSelected} />
Â  Â  </div>
Â  )
}

// ==== FILE: app\admin\dashboard\page.tsx ====
import AdminDashboard from '@/components/admin/AdminDashboard'

export const runtime = 'nodejs'

export default async function Page() {
Â  return <AdminDashboard sectionKey="dashboard" />
}

// ==== FILE: app\admin\debug\page.tsx ====
import AdminDashboard from '@/components/admin/AdminDashboard'

export const runtime = 'nodejs'

export default function Page() { return <AdminDashboard sectionKey="debug" /> }

// ==== FILE: app\admin\media\page.tsx ====
import AdminDashboard from '@/components/admin/AdminDashboard'

export const runtime = 'nodejs'

export default function Page() { return <AdminDashboard sectionKey="media" /> }

// ==== FILE: app\admin\plugins\page.tsx ====
import AdminDashboard from '@/components/admin/AdminDashboard'

export const runtime = 'nodejs'

export default function Page() { return <AdminDashboard sectionKey="plugins" /> }

// ==== FILE: app\admin\posts\page.tsx ====
import AdminDashboard from '@/components/admin/AdminDashboard'

export const runtime = 'nodejs'

export default function Page() { return <AdminDashboard sectionKey="posts" /> }

// ==== FILE: app\admin\posts\new\edit\page.tsx ====
export default function NewPostEditPage() {
Â  return (
Â  Â  <div className="p-6">
Â  Â  Â  <h1 className="text-xl font-semibold mb-2">New Post Editor</h1>
Â  Â  Â  <p className="text-sm text-muted-foreground">Inline editor coming soon. Use Posts section tiles to create and autosave drafts.</p>
Â  Â  </div>
Â  )
}

// ==== FILE: app\admin\posts[id]\edit\page.tsx ====
import { notFound } from 'next/navigation'

import PostEditorPageClient from '@/components/admin/PostEditorPageClient'

export const runtime = 'nodejs'

async function fetchPost(id: string) {
Â  const res = await fetch(${process.env.NEXT_PUBLIC_SITE_URL || ''}/api/wp/posts?id=${id}, { cache: 'no-store' })
Â  if (!res.ok) return null
Â  const p: unknown = await res.json()
Â  return p
}

export default async function EditPostPage({ params }: { params: { id: string } }) {
Â  const { id } = params
Â  if (!id) notFound()
Â  // Role gate via Roles Matrix API (single source of truth)
Â  const rmRes = await fetch('/api/roles/matrix', { cache: 'no-store' })
Â  if (!rmRes.ok) notFound()
Â  const matrix: unknown = await rmRes.json()
Â  if (!matrix || typeof matrix !== 'object' || !('can' in matrix) || typeof (matrix as {can: unknown}).can !== 'object' || !(matrix as {can: {posts?: unknown}}).can?.posts || typeof (matrix as {can: {posts: unknown}}).can.posts !== 'object' || !((matrix as {can: {posts: {edit?: unknown}}}).can.posts as {edit?:unknown})?.edit) {
Â  Â  notFound()
Â  }
Â  const post = await fetchPost(id)
Â  if (!post || typeof post !== 'object') notFound()

Â  const postObj = post as Record<string, unknown>
Â  const titleObj = postObj.title as { rendered?: string } | string
Â  const contentObj = postObj.content as { rendered?: string } | string
Â  const excerptObj = postObj.excerpt as { rendered?: string } | string

Â  const title = typeof titleObj === 'string' ? titleObj : titleObj?.rendered || ''
Â  const content = typeof contentObj === 'string' ? contentObj : contentObj?.rendered || ''
Â  const excerpt = typeof excerptObj === 'string' ? excerptObj : excerptObj?.rendered || ''
Â  const status = typeof postObj.status === 'string' ? postObj.status : 'draft'

Â  return (
Â  Â  <PostEditorPageClient postId={Number(id)} initial={{ title, content, excerpt, status }} />
Â  )
}

// ==== FILE: app\admin\settings\page.tsx ====
import AdminDashboard from '@/components/admin/AdminDashboard'

export const runtime = 'nodejs'

export default function Page() { return <AdminDashboard sectionKey="settings" /> }

// ==== FILE: app\admin\site-health\page.tsx ====
import AdminDashboard from '@/components/admin/AdminDashboard'

export const runtime = 'nodejs'

export default function Page() { return <AdminDashboard sectionKey="site-health" /> }

// ==== FILE: app\admin\tags\page.tsx ====
import AdminDashboard from '@/components/admin/AdminDashboard'

export const runtime = 'nodejs'

export default function Page() { return <AdminDashboard sectionKey="tags" /> }

// ==== FILE: app\admin\themes\page.tsx ====
import AdminDashboard from '@/components/admin/AdminDashboard'

export const runtime = 'nodejs'

export default function Page() { return <AdminDashboard sectionKey="themes" /> }

// ==== FILE: app\admin\users\page.tsx ====
import AdminDashboard from '@/components/admin/AdminDashboard'

export const runtime = 'nodejs'

export default function Page() { return <AdminDashboard sectionKey="users" /> }

// ==== FILE: app\admin\users\pageClient.tsx ====
"use client"

import { useMemo, useState } from 'react'
import { MoreHorizontal, Search, UserPlus } from 'lucide-react'

import { Input } from '@/components/ui/input'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { Badge } from '@/components/ui/badge'
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuLabel, DropdownMenuTrigger } from '@/components/ui/dropdown-menu'
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar'
import BulkActionsBar, { BulkAction } from '@/components/admin/BulkActionsBar'
import SelectableTable from '@/components/admin/SelectableTable'

const dummyUsers = [
Â  { id: 1, name: "Jane Doe", email: "jane.doe@example.com", role: "Administrator", avatar: "https://i.pravatar.cc/150?u=a042581f4e29026704d" },
Â  { id: 2, name: "John Smith", email: "john.smith@example.com", role: "Editor", avatar: "https://i.pravatar.cc/150?u=a042581f4e29026705d" },
Â  { id: 3, name: "Emily White", email: "emily.white@example.com", role: "Author", avatar: "https://i.pravatar.cc/150?u=a042581f4e29026706d" },
Â  { id: 4, name: "Chris Green", email: "chris.green@example.com", role: "Subscriber", avatar: "https://i.pravatar.cc/150?u=a042581f4e29026707d" },
];

export default function UsersClient() {
Â  const [selected, setSelected] = useState<number[]>([])
Â  const header = useMemo(()=>['User','Role','Actions'],[])
Â  const rows = useMemo(()=> dummyUsers.map(u => ({
Â  Â  id: u.id,
Â  Â  cells: [
Â  Â  Â  <div className="flex items-center gap-3" key="user">
Â  Â  Â  Â  <Avatar>
Â  Â  Â  Â  Â  <AvatarImage src={u.avatar} alt={u.name} />
Â  Â  Â  Â  Â  <AvatarFallback>{u.name.charAt(0)}</AvatarFallback>
Â  Â  Â  Â  </Avatar>
Â  Â  Â  Â  <div>
Â  Â  Â  Â  Â  <p className="font-medium">{u.name}</p>
Â  Â  Â  Â  Â  <p className="text-sm text-muted-foreground">{u.email}</p>
Â  Â  Â  Â  </div>
Â  Â  Â  </div>,
Â  Â  Â  <Badge variant="outline" key="role">{u.role}</Badge>,
Â  Â  Â  <div key="actions" className="text-right">
Â  Â  Â  Â  <DropdownMenu>
Â  Â  Â  Â  Â  <DropdownMenuTrigger asChild>
Â  Â  Â  Â  Â  Â  <Button variant="ghost" className="h-8 w-8 p-0">
Â  Â  Â  Â  Â  Â  Â  <span className="sr-only">Open menu</span>
Â  Â  Â  Â  Â  Â  Â  <MoreHorizontal className="h-4 w-4" />
Â  Â  Â  Â  Â  Â  </Button>
Â  Â  Â  Â  Â  </DropdownMenuTrigger>
Â  Â  Â  Â  Â  <DropdownMenuContent align="end">
Â  Â  Â  Â  Â  Â  <DropdownMenuLabel>Actions</DropdownMenuLabel>
Â  Â  Â  Â  Â  Â  <DropdownMenuItem>Edit User</DropdownMenuItem>
Â  Â  Â  Â  Â  Â  <DropdownMenuItem>View Profile</DropdownMenuItem>
Â  Â  Â  Â  Â  Â  <DropdownMenuItem className="text-red-500">Delete User</DropdownMenuItem>
Â  Â  Â  Â  Â  </DropdownMenuContent>
Â  Â  Â  Â  </DropdownMenu>
Â  Â  Â  </div>
Â  Â  ]
Â  })), [])

Â  const onAction = async (action: BulkAction) => {
Â  Â  if (action !== 'delete' || selected.length === 0) return
Â  Â  const res = await fetch('/api/wp/users/bulk-delete', {
Â  Â  Â  method: 'POST',
Â  Â  Â  headers: { 'Content-Type': 'application/json' },
Â  Â  Â  body: JSON.stringify({ ids: selected })
Â  Â  })
Â  Â  if (!res.ok) throw new Error('Bulk delete failed')
Â  }

Â  return (
Â  Â  <div>
Â  Â  Â  <div className="flex justify-between items-center mb-8">
Â  Â  Â  Â  <Button><UserPlus className="mr-2 h-4 w-4" /> Add User</Button>
Â  Â  Â  </div>

Â  Â  Â  <Card>
Â  Â  Â  Â  <CardHeader>
Â  Â  Â  Â  Â  <CardTitle>All Users</CardTitle>
Â  Â  Â  Â  Â  <div className="mt-4 flex flex-col md:flex-row gap-4">
Â  Â  Â  Â  Â  Â  <div className="relative flex-1">
Â  Â  Â  Â  Â  Â  Â  <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-muted-foreground" />
Â  Â  Â  Â  Â  Â  Â  <Input placeholder="Search users by name or email..." className="pl-10" />
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  <Select>
Â  Â  Â  Â  Â  Â  Â  <SelectTrigger className="w-full md:w-[180px]">
Â  Â  Â  Â  Â  Â  Â  Â  <SelectValue placeholder="Filter by role" />
Â  Â  Â  Â  Â  Â  Â  </SelectTrigger>
Â  Â  Â  Â  Â  Â  Â  <SelectContent>
Â  Â  Â  Â  Â  Â  Â  Â  <SelectItem value="all">All Roles</SelectItem>
Â  Â  Â  Â  Â  Â  Â  Â  <SelectItem value="admin">Administrator</SelectItem>
Â  Â  Â  Â  Â  Â  Â  Â  <SelectItem value="editor">Editor</SelectItem>
Â  Â  Â  Â  Â  Â  Â  Â  <SelectItem value="author">Author</SelectItem>
Â  Â  Â  Â  Â  Â  Â  Â  <SelectItem value="subscriber">Subscriber</SelectItem>
Â  Â  Â  Â  Â  Â  Â  </SelectContent>
Â  Â  Â  Â  Â  Â  </Select>
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </CardHeader>
Â  Â  Â  Â  <CardContent>
Â  Â  Â  Â  Â  <BulkActionsBar onAction={onAction} disabled={selected.length===0} />
Â  Â  Â  Â  Â  <SelectableTable rows={rows} header={header} onSelectionChange={setSelected} />
Â  Â  Â  Â  </CardContent>
Â  Â  Â  </Card>
Â  Â  </div>
Â  )
}

// ==== FILE: app\admin\users\UsersClient.tsx ====
"use client"

import { useMemo, useState } from 'react'
import { MoreHorizontal, Search, UserPlus } from 'lucide-react'

import { Input } from '@/components/ui/input'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { Badge } from '@/components/ui/badge'
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuLabel, DropdownMenuTrigger } from '@/components/ui/dropdown-menu'
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar'
import BulkActionsBar, { BulkAction } from '@/components/admin/BulkActionsBar'
import SelectableTable from '@/components/admin/SelectableTable'

const dummyUsers = [
Â  { id: 1, name: "Jane Doe", email: "jane.doe@example.com", role: "Administrator", avatar: "https://i.pravatar.cc/150?u=a042581f4e29026704d" },
Â  { id: 2, name: "John Smith", email: "john.smith@example.com", role: "Editor", avatar: "https://i.pravatar.cc/150?u=a042581f4e29026705d" },
Â  { id: 3, name: "Emily White", email: "emily.white@example.com", role: "Author", avatar: "https://i.pravatar.cc/150?u=a042581f4e29026706d" },
Â  { id: 4, name: "Chris Green", email: "chris.green@example.com", role: "Subscriber", avatar: "https://i.pravatar.cc/150?u=a042581f4e29026707d" },
];

export default function UsersClient() {
Â  const [selected, setSelected] = useState<number[]>([])
Â  const header = useMemo(()=>['User','Role','Actions'],[])
Â  const rows = useMemo(()=> dummyUsers.map(u => ({
Â  Â  id: u.id,
Â  Â  cells: [
Â  Â  Â  <div className="flex items-center gap-3" key="user">
Â  Â  Â  Â  <Avatar>
Â  Â  Â  Â  Â  <AvatarImage src={u.avatar} alt={u.name} />
Â  Â  Â  Â  Â  <AvatarFallback>{u.name.charAt(0)}</AvatarFallback>
Â  Â  Â  Â  </Avatar>
Â  Â  Â  Â  <div>
Â  Â  Â  Â  Â  <p className="font-medium">{u.name}</p>
Â  Â  Â  Â  Â  <p className="text-sm text-muted-foreground">{u.email}</p>
Â  Â  Â  Â  </div>
Â  Â  Â  </div>,
Â  Â  Â  <Badge variant="outline" key="role">{u.role}</Badge>,
Â  Â  Â  <div key="actions" className="text-right">
Â  Â  Â  Â  <DropdownMenu>
Â  Â  Â  Â  Â  <DropdownMenuTrigger asChild>
Â  Â  Â  Â  Â  Â  <Button variant="ghost" className="h-8 w-8 p-0">
Â  Â  Â  Â  Â  Â  Â  <span className="sr-only">Open menu</span>
Â  Â  Â  Â  Â  Â  Â  <MoreHorizontal className="h-4 w-4" />
Â  Â  Â  Â  Â  Â  </Button>
Â  Â  Â  Â  Â  </DropdownMenuTrigger>
Â  Â  Â  Â  Â  <DropdownMenuContent align="end">
Â  Â  Â  Â  Â  Â  <DropdownMenuLabel>Actions</DropdownMenuLabel>
Â  Â  Â  Â  Â  Â  <DropdownMenuItem>Edit User</DropdownMenuItem>
Â  Â  Â  Â  Â  Â  <DropdownMenuItem>View Profile</DropdownMenuItem>
Â  Â  Â  Â  Â  Â  <DropdownMenuItem className="text-red-500">Delete User</DropdownMenuItem>
Â  Â  Â  Â  Â  </DropdownMenuContent>
Â  Â  Â  Â  </DropdownMenu>
Â  Â  Â  </div>
Â  Â  ]
Â  })), [])

Â  const onAction = async (action: BulkAction) => {
Â  Â  if (action !== 'delete' || selected.length === 0) return
Â  Â  const res = await fetch('/api/wp/users/bulk-delete', {
Â  Â  Â  method: 'POST',
Â  Â  Â  headers: { 'Content-Type': 'application/json' },
Â  Â  Â  body: JSON.stringify({ ids: selected })
Â  Â  })
Â  Â  if (!res.ok) throw new Error('Bulk delete failed')
Â  }

Â  return (
Â  Â  <div>
Â  Â  Â  <div className="flex justify-between items-center mb-8">
Â  Â  Â  Â  <Button><UserPlus className="mr-2 h-4 w-4" /> Add User</Button>
Â  Â  Â  </div>

Â  Â  Â  <Card>
Â  Â  Â  Â  <CardHeader>
Â  Â  Â  Â  Â  <CardTitle>All Users</CardTitle>
Â  Â  Â  Â  Â  <div className="mt-4 flex flex-col md:flex-row gap-4">
Â  Â  Â  Â  Â  Â  <div className="relative flex-1">
Â  Â  Â  Â  Â  Â  Â  <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-muted-foreground" />
Â  Â  Â  Â  Â  Â  Â  <Input placeholder="Search users by name or email..." className="pl-10" />
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  <Select>
Â  Â  Â  Â  Â  Â  Â  <SelectTrigger className="w-full md:w-[180px]">
Â  Â  Â  Â  Â  Â  Â  Â  <SelectValue placeholder="Filter by role" />
Â  Â  Â  Â  Â  Â  Â  </SelectTrigger>
Â  Â  Â  Â  Â  Â  Â  <SelectContent>
Â  Â  Â  Â  Â  Â  Â  Â  <SelectItem value="all">All Roles</SelectItem>
Â  Â  Â  Â  Â  Â  Â  Â  <SelectItem value="admin">Administrator</SelectItem>
Â  Â  Â  Â  Â  Â  Â  Â  <SelectItem value="editor">Editor</SelectItem>
Â  Â  Â  Â  Â  Â  Â  Â  <SelectItem value="author">Author</SelectItem>
Â  Â  Â  Â  Â  Â  Â  Â  <SelectItem value="subscriber">Subscriber</SelectItem>
Â  Â  Â  Â  Â  Â  Â  </SelectContent>
Â  Â  Â  Â  Â  Â  </Select>
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </CardHeader>
Â  Â  Â  Â  <CardContent>
Â  Â  Â  Â  Â  <BulkActionsBar onAction={onAction} disabled={selected.length===0} />
Â  Â  Â  Â  Â  <SelectableTable rows={rows} header={header} onSelectionChange={setSelected} />
Â  Â  Â  Â  </CardContent>
Â  Â  Â  </Card>
Â  Â  </div>
Â  )
}

// ==== FILE: app\api\admin\route.ts ====
import { NextResponse } from 'next/server'

import { requireRole } from '../../../src/lib/auth'

export async function GET() {
Â  try {
Â  Â  await requireRole('administrator')
Â  Â  return NextResponse.json({ ok: true })
Â  } catch (err: unknown) {
Â  Â  const message = (err instanceof Error) ? err.message : 'Forbidden'
Â  Â  const status = (err instanceof Error && 'status' in err) ? (err as {status: number}).status : 403
Â  Â  return NextResponse.json({ message: message || 'Forbidden' }, { status: status ?? 403 })
Â  }
}

// ==== FILE: app\api\analytics\check\route.ts ====
import { apiMap } from '@/lib/wpAPIMap'
import { fetchWithAuth, MissingWpTokenError } from '@/lib/fetchWithAuth'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

export async function GET(req: Request) {
Â  try {
Â  Â  const url = apiMap.analytics.check
Â  Â  if (!url) return new Response(JSON.stringify({ error: 'WP_URL env required' }), { status: 500 })
Â  Â  return await fetchWithAuth(req, url)
Â  } catch (err: unknown) {
Â  Â  if (err instanceof MissingWpTokenError) {
Â  Â  Â  return new Response(JSON.stringify({ error: 'unauthorized', message: err.message }), { status: err.status, headers: { 'Content-Type': 'application/json' } })
Â  Â  }
Â  Â  console.error('analytics.check unexpected error:', err)
Â  Â  return new Response(JSON.stringify({ error: 'proxy_error', message: 'Failed to check analytics' }), { status: 502, headers: { 'Content-Type': 'application/json' } })
Â  }
}

// ==== FILE: app\api\analytics\countries\route.ts ====
import { apiMap } from '@/lib/wpAPIMap'
import { fetchWithAuth } from '@/lib/fetchWithAuth'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

export async function GET(req: Request) {
Â  const base = apiMap.analytics.countries
Â  if (!base) return new Response(JSON.stringify({ error: 'WP_URL env required' }), { status: 500 })
Â  const inUrl = new URL(req.url)
Â  const period = inUrl.searchParams.get('period') || 'month'
Â  const u = new URL(base)
Â  u.searchParams.set('period', period)
Â  return fetchWithAuth(req, u.toString())
}

// ==== FILE: app\api\analytics\devices\route.ts ====
import { apiMap } from '@/lib/wpAPIMap'
import { fetchWithAuth } from '@/lib/fetchWithAuth'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

export async function GET(req: Request) {
Â  const base = apiMap.analytics.devices
Â  if (!base) return new Response(JSON.stringify({ error: 'WP_URL env required' }), { status: 500 })
Â  const inUrl = new URL(req.url)
Â  const period = inUrl.searchParams.get('period') || 'month'
Â  const u = new URL(base)
Â  u.searchParams.set('period', period)
Â  return fetchWithAuth(req, u.toString())
}

// ==== FILE: app\api\analytics\export\route.ts ====
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

function toCSV(rows: unknown[], headers?: string[]) {
Â  if (!Array.isArray(rows) || rows.length === 0) return ''
Â  const firstRow = rows[0]
Â  if (typeof firstRow !== 'object' || firstRow === null) return ''

Â  const cols = headers || Object.keys(firstRow)
Â  const esc = (v: unknown) => {
Â  Â  if (v == null) return ''
Â  Â  const s = String(v)
Â  Â  if (/[",\n]/.test(s)) return '"' + s.replace(/"/g, '""') + '"'
Â  Â  return s
Â  }
Â  const out = [cols.join(',')]
Â  for (const r of rows) {
Â  Â  if (typeof r !== 'object' || r === null) continue
Â  Â  out.push(cols.map(c => esc((r as Record<string, unknown>)[c])).join(','))
Â  }
Â  return out.join('\n')
}

export async function GET(req: Request) {
Â  const inUrl = new URL(req.url)
Â  const type = inUrl.searchParams.get('type') || 'views'
Â  const period = inUrl.searchParams.get('period') || 'month'
Â  const postId = inUrl.searchParams.get('postId') || ''

Â  let api = ''
Â  if (type === 'views') {
Â  Â  api = /api/analytics/views?period=${encodeURIComponent(period)}${postId ? &postId=${encodeURIComponent(postId)} : ''}
Â  } else if (type === 'top-posts') {
Â  Â  api = /api/analytics/top-posts?period=${encodeURIComponent(period)}
Â  } else if (type === 'devices') {
Â  api = /api/analytics/summary?period=${encodeURIComponent(period)}
Â  } else if (type === 'countries') {
Â  api = /api/analytics/summary?period=${encodeURIComponent(period)}
Â  } else if (type === 'referers') {
Â  api = /api/analytics/summary?period=${encodeURIComponent(period)}
Â  } else {
Â  Â  return new Response('unknown type', { status: 400 })
Â  }

Â  const origin = inUrl.origin
Â  const res = await fetch(new URL(api, origin), { headers: { cookie: req.headers.get('cookie') || '' } })
Â  if (!res.ok) return new Response(await res.text(), { status: res.status })
Â  const data: unknown = await res.json()
Â  let csv = ''

Â  if (typeof data !== 'object' || data === null) {
Â  Â  return new Response('Invalid data from upstream API', { status: 502 });
Â  }

Â  const dataObj = data as Record<string, unknown>

Â  if (type === 'views') {
Â  Â  const series = 'series' in dataObj && Array.isArray(dataObj.series) ? dataObj.series : []
Â  Â  csv = toCSV(series, ['date','views'])
Â  } else if (type === 'top-posts') {
Â  Â  csv = toCSV(Array.isArray(data) ? data : [], ['id','slug','title','views'])
Â  } else if (type === 'devices') {
Â  Â  const devices = 'devices' in dataObj && Array.isArray(dataObj.devices) ? dataObj.devices : []
Â  Â  csv = toCSV(devices, ['device_type','count'])
Â  } else if (type === 'countries') {
Â  Â  const countries = 'countries' in dataObj && Array.isArray(dataObj.countries) ? dataObj.countries : []
Â  Â  csv = toCSV(countries, ['country_code','count'])
Â  } else if (type === 'referers') {
Â  Â  const referers = 'referers' in dataObj && Array.isArray(dataObj.referers) ? dataObj.referers : []
Â  Â  csv = toCSV(referers, ['source','count','category'])
Â  }
Â  return new Response(csv, { status: 200, headers: { 'Content-Type': 'text/csv', 'Content-Disposition': attachment; filename="${type}-${period}.csv" } })
}

// ==== FILE: app\api\analytics\referers\route.ts ====
import { apiMap } from '@/lib/wpAPIMap'
import { fetchWithAuth } from '@/lib/fetchWithAuth'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

export async function GET(req: Request) {
Â  const base = apiMap.analytics.referers
Â  if (!base) return new Response(JSON.stringify({ error: 'WP_URL env required' }), { status: 500 })
Â  const inUrl = new URL(req.url)
Â  const period = inUrl.searchParams.get('period') || 'month'
Â  const u = new URL(base)
Â  u.searchParams.set('period', period)
Â  return fetchWithAuth(req, u.toString())
}

// ==== FILE: app\api\analytics\sessions\route.ts ====
import { apiMap } from '@/lib/wpAPIMap'
import { fetchWithAuth } from '@/lib/fetchWithAuth'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

export async function GET(req: Request) {
Â  const base = apiMap.analytics.sessions
Â  if (!base) return new Response(JSON.stringify({ error: 'WP_URL env required' }), { status: 500 })
Â  const inUrl = new URL(req.url)
Â  const period = inUrl.searchParams.get('period') || 'month'
Â  const u = new URL(base)
Â  u.searchParams.set('period', period)
Â  return fetchWithAuth(req, u.toString())
}

// ==== FILE: app\api\analytics\sessions\summary\route.ts ====
import { fetchWithAuth } from '@/lib/fetchWithAuth'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'
const WP = (process.env.WP_URL || '').replace(//$/, '')

export async function GET(req: Request) {
Â  if (!WP) return Response.json({ error: 'WP_URL env required' }, { status: 500 })
Â  return fetchWithAuth(req, ${WP}/wp-json/fe-analytics/v1/sessions/summary)
}

// ==== FILE: app\api\analytics\sessions\timeseries\route.ts ====
import { fetchWithAuth } from '@/lib/fetchWithAuth'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'
const WP = (process.env.WP_URL || '').replace(//$/, '')

export async function GET(req: Request) {
Â  if (!WP) return Response.json({ error: 'WP_URL env required' }, { status: 500 })
Â  return fetchWithAuth(req, ${WP}/wp-json/fe-analytics/v1/sessions/timeseries)
}

// ==== FILE: app\api\analytics\stream\route.ts ====
import { getWpTokenFromRequest } from '@/lib/fetchWithAuth'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'
const WP = (process.env.WP_URL || '').replace(//$/, '')

export async function GET(req: Request) {
Â  if (!WP) return new Response('WP_URL not set', { status: 500 })
Â  const token = await getWpTokenFromRequest(req)
Â  if (!token) return new Response('Unauthorized', { status: 401 })
Â  const upstream = await fetch(${WP}/wp-json/fe-analytics/v1/stream, {
Â  Â  headers: {
Â  Â  Â  Authorization: Bearer ${token},
Â  Â  Â  Cookie: Authorization=Bearer ${token},
Â  Â  Â  Accept: 'text/event-stream',
Â  Â  },
Â  })
Â  if (!upstream.body) return new Response('No stream', { status: 502 })
Â  return new Response(upstream.body, { headers: { 'Content-Type': 'text/event-stream', 'Cache-Control': 'no-cache', Connection: 'keep-alive' } })
}

// ==== FILE: app\api\analytics\summary\route.ts ====
import { cookies } from 'next/headers'

import { apiMap } from '@/lib/wpAPIMap'
import { fetchWithAuth, MissingWpTokenError } from '@/lib/fetchWithAuth'
import { SessionClaims, verifySession } from '@/lib/jwt'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

export async function GET(req: Request) {
Â  try {
Â  Â  // Derive wpToken from session cookie (or fall back to request parsing in fetchWithAuth)
Â  Â  let wpToken: string | null = null
Â  Â  try {
Â  Â  Â  const store = await cookies()
Â  Â  Â  const sessionCookie = store.get(process.env.SESSION_COOKIE_NAME ?? 'session')?.value
Â  Â  Â  if (sessionCookie) {
Â  Â  Â  Â  const claims = await verifySession(sessionCookie)
Â  Â  Â  Â  wpToken = claims?.wpToken || null
Â  Â  Â  }
Â  Â  } catch (_e) {
Â  Â  Â  // ignore cookie/verify errors; fetchWithAuth will throw if no token
// TODO: implement
Â  Â  }
Â  Â  const inUrl = new URL(req.url)
Â  Â  const period = inUrl.searchParams.get('period') || 'month'
Â  Â  const refresh = inUrl.searchParams.get('refresh') || ''

Â  Â  const { analytics } = apiMap
Â  Â  const endpoints = {
Â  Â  Â  views: analytics.views,
Â  Â  Â  devices: analytics.devices,
Â  Â  Â  countries: analytics.countries,
Â  Â  Â  referers: analytics.referers,
Â  Â  }
Â  Â  if (!endpoints.views) {
Â  Â  Â  return new Response(JSON.stringify({ error: 'WP_URL env required' }), { status: 500, headers: { 'Content-Type': 'application/json' } })
Â  Â  }

Â  Â  const buildUrl = (base: string) => {
Â  Â  Â  const u = new URL(base)
Â  Â  Â  u.searchParams.set('period', period)
Â  Â  Â  if (refresh) u.searchParams.set('refresh', refresh)
Â  Â  Â  return u.toString()
Â  Â  }

Â  Â  // Fetch concurrently; apply light ISR-style caching
Â  Â  const tokenOrReq = wpToken || req
Â  Â  const [viewsRes, devicesRes, countriesRes, referersRes] = await Promise.all([
Â  Â  Â  fetchWithAuth(tokenOrReq, buildUrl(endpoints.views), { next: { revalidate: 60 } }),
Â  Â  Â  endpoints.devices ? fetchWithAuth(tokenOrReq, buildUrl(endpoints.devices), { next: { revalidate: 60 } }) : Promise.resolve(new Response('{}', { status: 204 })),
Â  Â  Â  endpoints.countries ? fetchWithAuth(tokenOrReq, buildUrl(endpoints.countries), { next: { revalidate: 60 } }) : Promise.resolve(new Response('{}', { status: 204 })),
Â  Â  Â  endpoints.referers ? fetchWithAuth(tokenOrReq, buildUrl(endpoints.referers), { next: { revalidate: 60 } }) : Promise.resolve(new Response('{}', { status: 204 })),
Â  Â  ])

Â  Â  const parseJSON = async (r: Response) => {
Â  Â  Â  if (!r || r.status === 204) return null
Â  Â  Â  const t = await r.text()
Â  Â  Â  try { return t ? JSON.parse(t) : null } catch { return { raw: t } }
Â  Â  }

Â  Â  const [views, devices, countries, referers] = await Promise.all([
Â  Â  Â  parseJSON(viewsRes),
Â  Â  Â  parseJSON(devicesRes),
Â  Â  Â  parseJSON(countriesRes),
Â  Â  Â  parseJSON(referersRes),
Â  Â  ])

Â  Â  const status = Math.max(viewsRes.status, devicesRes.status, countriesRes.status, referersRes.status)
Â  Â  const body = { summary: { views, devices, countries, referers } }
Â  Â  if (status === 401 || status === 403) {
Â  Â  Â  return new Response(JSON.stringify({ error: 'unauthorized', message: 'Not authorized to view analytics' }), { status, headers: { 'Content-Type': 'application/json' } })
Â  Â  }
Â  Â  return new Response(JSON.stringify(body), { status: status >= 400 ? 502 : 200, headers: { 'Content-Type': 'application/json' } })
Â  } catch (err: unknown) {
Â  Â  if (err instanceof MissingWpTokenError) {
Â  Â  Â  return new Response(JSON.stringify({ error: 'unauthorized', message: err.message }), { status: err.status, headers: { 'Content-Type': 'application/json' } })
Â  Â  }
Â  Â  const message = (err instanceof Error) ? err.message : 'Failed to fetch analytics summary'
Â  Â  console.error('analytics.summary unexpected error:', err)
Â  Â  return new Response(JSON.stringify({ error: 'proxy_error', message }), { status: 502, headers: { 'Content-Type': 'application/json' } })
Â  }
}

// ==== FILE: app\api\analytics\top-posts\route.ts ====
import { apiMap } from '@/lib/wpAPIMap'
import { fetchWithAuth } from '@/lib/fetchWithAuth'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

export async function GET(req: Request) {
Â  try {
Â  Â  const base = apiMap.analytics.topPosts
Â  Â  if (!base) {
Â  Â  Â  return new Response(JSON.stringify({ error: 'WP_URL env required' }), { status: 500, headers: { 'Content-Type': 'application/json' } })
Â  Â  }
Â  Â  const inUrl = new URL(req.url)
Â  Â  const period = inUrl.searchParams.get('period') || 'month'
Â  Â  const limit = inUrl.searchParams.get('limit') || '10'
Â  Â  const u = new URL(base)
Â  Â  u.searchParams.set('period', period)
Â  Â  u.searchParams.set('limit', limit)

Â  Â  // Light caching to reduce WP load
Â  Â  const resp = await fetchWithAuth(req, u.toString(), { next: { revalidate: 60 } })
Â  Â  return resp
Â  } catch (err: unknown) {
Â  Â  const message = (err instanceof Error) ? err.message : 'Failed to fetch top posts'
Â  Â  return new Response(JSON.stringify({ error: 'proxy_error', message }), { status: 502, headers: { 'Content-Type': 'application/json' } })
Â  }
}

// ==== FILE: app\api\analytics\views\route.ts ====
import { apiMap } from '@/lib/wpAPIMap'
import { fetchWithAuth, MissingWpTokenError } from '@/lib/fetchWithAuth'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

export async function GET(req: Request) {
Â  try {
Â  Â  const base = apiMap.analytics.views
Â  Â  if (!base) return new Response(JSON.stringify({ error: 'WP_URL env required' }), { status: 500 })
Â  Â  const inUrl = new URL(req.url)
Â  Â  const period = inUrl.searchParams.get('period') || 'month'
Â  Â  const postId = inUrl.searchParams.get('postId')
Â  Â  const u = new URL(base)
Â  Â  u.searchParams.set('period', period)
Â  Â  if (postId) u.searchParams.set('post_id', postId)
Â  Â  return await fetchWithAuth(req, u.toString())
Â  } catch (err: unknown) {
Â  Â  if (err instanceof MissingWpTokenError) {
Â  Â  Â  return new Response(JSON.stringify({ error: 'unauthorized', message: err.message }), { status: err.status, headers: { 'Content-Type': 'application/json' } })
Â  Â  }
Â  Â  console.error('analytics.views unexpected error:', err)
Â  Â  return new Response(JSON.stringify({ error: 'proxy_error', message: 'Failed to fetch analytics views' }), { status: 502, headers: { 'Content-Type': 'application/json' } })
Â  }
}

// ==== FILE: app\api\auth\login\route.ts ====
import { z } from 'zod'

import { signSession } from '../../../../src/lib/jwt'
import { logWPError } from '../../../../src/lib/log'
import { validateCsrf, validateCsrfFromRequest } from '../../../../src/lib/csrf'

const schema = z.object({ identifier: z.string().min(1), password: z.string().min(1) })

type WpTokenResponse = {
Â  token: string;
Â  user_email: string;
Â  user_nicename: string;
Â  user_display_name: string;
Â  user_id?: number;
};

type WpUserMeResponse = {
Â  roles?: string[];
}

export async function POST(req: Request) {
Â  // CSRF double-submit protection
Â  const csrfHeader = req.headers.get('x-csrf-token') || undefined
Â  // Validate via cookies() or directly from request headers; accept either for robustness
Â  const ok = validateCsrf(csrfHeader) || validateCsrfFromRequest(req, csrfHeader)
Â  if (!ok) {
Â  Â  console.warn('CSRF validation failed', {
Â  Â  Â  hasHeader: Boolean(csrfHeader),
Â  Â  Â  hasCookieHeader: Boolean(req.headers.get('cookie')),
Â  Â  })
Â  Â  return new Response(JSON.stringify({ error: 'Invalid CSRF' }), { status: 403, headers: { 'Content-Type': 'application/json' } })
Â  }
Â  const body = await req.json()
Â  const { identifier, password } = schema.parse(body)
Â  let data: unknown;
Â Â 
Â  try {
Â  Â  // Direct fetch to WordPress JWT endpoint
Â  Â  const wpUrl = process.env.WP_URL || 'http://example.com'
Â  Â  // Add a timeout to avoid hanging requests
Â  Â  const controller = new AbortController()
Â  Â  const timeout = setTimeout(() => controller.abort(), 10000)
Â  Â  const response = await fetch(${wpUrl}/wp-json/jwt-auth/v1/token, {
Â  Â  Â  method: 'POST',
Â  Â  Â  headers: {
Â  Â  Â  Â  'Content-Type': 'application/json',
Â  Â  Â  Â  'User-Agent': 'tech-oblivion-fe/1.0',
Â  Â  Â  },
Â  Â  Â  body: JSON.stringify({ username: identifier, password }),
Â  Â  Â  signal: controller.signal,
Â  Â  }).finally(() => clearTimeout(timeout))

Â  Â  if (!response.ok) {
Â  Â  Â  const errorData = await response.json().catch(() => ({}))
Â  Â  Â  logWPError('jwt-auth-failed', {Â 
Â  Â  Â  Â  status: response.status,Â 
Â  Â  Â  Â  statusText: response.statusText,
Â  Â  Â  Â  body: JSON.stringify(errorData)
Â  Â  Â  })
Â  Â  Â Â 
Â  Â  Â  if (response.status === 403) {
Â  Â  Â  Â  return new Response(JSON.stringify({Â 
Â  Â  Â  Â  Â  error: 'Invalid credentials',Â 
Â  Â  Â  Â  Â  message: 'Username or password is incorrect'Â 
Â  Â  Â  Â  }), {Â 
Â  Â  Â  Â  Â  status: 401,Â 
Â  Â  Â  Â  Â  headers: { 'Content-Type': 'application/json' }Â 
Â  Â  Â  Â  })
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return new Response(JSON.stringify({Â 
Â  Â  Â  Â  error: 'WordPress authentication failed',Â 
Â  Â  Â  Â  details: errorDataÂ 
Â  Â  Â  }), {Â 
Â  Â  Â  Â  status: response.status,Â 
Â  Â  Â  Â  headers: { 'Content-Type': 'application/json' }Â 
Â  Â  Â  })
Â  Â  }

Â  Â  data = await response.json()
Â  Â Â 
Â  } catch (err: unknown) {
Â  Â  const error = err as Error
Â  Â  console.error('WordPress connection error:', error)
Â  Â  logWPError('wordpress-connection-error', {Â 
Â  Â  Â  statusText: error.message,
Â  Â  Â  body: error.stack || ''
Â  Â  })
Â  Â Â 
Â  Â  return new Response(JSON.stringify({Â 
Â  Â  Â  error: 'Unable to reach WordPress backend',Â 
Â  Â  Â  details: error.messageÂ 
Â  Â  }), {Â 
Â  Â  Â  status: 502,Â 
Â  Â  Â  headers: { 'Content-Type': 'application/json' }Â 
Â  Â  })
Â  }

Â  if (typeof data !== 'object' || data === null || !('token' in data)) {
Â  Â  return new Response(JSON.stringify({ error: 'Invalid response from WordPress' }), { status: 502, headers: { 'Content-Type': 'application/json' } });
Â  }

Â  // JWT auth endpoint returns token and user info
Â  const { token, user_email, user_nicename, user_display_name, user_id } = data as WpTokenResponse;

Â  // Try to enrich roles via WP /users/me (requires edit context)
Â  let wpRoles: string[] | undefined = undefined
Â  try {
Â  Â  const wpUrl = process.env.WP_URL || 'http://example.com'
Â  Â  const meResp = await fetch(${wpUrl}/wp-json/wp/v2/users/me?context=edit, {
Â  Â  Â  headers: {
Â  Â  Â  Â  'Authorization': Bearer ${token},
Â  Â  Â  Â  'User-Agent': 'tech-oblivion-fe/1.0',
Â  Â  Â  },
Â  Â  Â  cache: 'no-store',
Â  Â  })
Â  Â  if (meResp.ok) {
Â  Â  Â  const meJson = (await meResp.json()) as WpUserMeResponse;
Â  Â  Â  if (meJson && Array.isArray(meJson.roles)) {
Â  Â  Â  Â  wpRoles = meJson.roles
Â  Â  Â  }
Â  Â  }
Â  } catch (_e) {
Â  Â  // ignore; fallback to default below
// TODO: implement
Â  }

Â  // Create session with the user data from JWT response
Â  // IMPORTANT: include the upstream WP JWT as wpToken so protected proxy routes can authenticate.
Â  const sessionToken = await signSession({Â 
Â  Â  sub: String(user_id || user_nicename),Â 
Â  Â  username: user_nicename,Â 
Â  Â  email: user_email,Â 
Â  	roles: Array.isArray(wpRoles) && wpRoles.length ? wpRoles : ['subscriber'],
Â  Â  wpUserId: user_id,
Â  Â  displayName: user_display_name,
Â  Â  wpToken: token,
Â  })

Â  // Only set Secure on HTTPS; using it on HTTP drops the cookie and causes auth loops
Â  const xfProto = req.headers.get('x-forwarded-proto')
Â  const isHttps = (xfProto ? xfProto.split(',')[0].trim() : '') === 'https' || new URL(req.url).protocol === 'https:'
Â  const cookie = ${process.env.SESSION_COOKIE_NAME || 'session'}=${sessionToken}; Path=/; Max-Age=${60 * 60 * 24 * 7}; SameSite=Lax; ${isHttps ? 'Secure; ' : ''}HttpOnly
Â Â 
Â  return new Response(JSON.stringify({Â 
Â  Â  user: {
Â  Â  Â  id: (data as WpTokenResponse).user_id || user_nicename,
Â  Â  Â  username: user_nicename,
Â  Â  Â  email: user_email,
Â  Â  Â  displayName: user_display_name
Â  Â  },
Â  Â  tokenÂ 
Â  }), { status: 200, headers: { 'Set-Cookie': cookie, 'Content-Type': 'application/json' } })
}

// ==== FILE: app\api\auth\logout\route.ts ====
export async function POST(req: Request) {
Â  const xfProto = req.headers.get('x-forwarded-proto')
Â  const isHttps = (xfProto ? xfProto.split(',')[0].trim() : '') === 'https' || new URL(req.url).protocol === 'https:'
Â  const cookie = ${process.env.SESSION_COOKIE_NAME || 'session'}=; Path=/; Max-Age=0; SameSite=Lax; ${isHttps ? 'Secure; ' : ''}HttpOnly
Â  return new Response(null, { status: 204, headers: { 'Set-Cookie': cookie } })
}

export async function GET(req: Request) {
Â  const xfProto = req.headers.get('x-forwarded-proto')
Â  const isHttps = (xfProto ? xfProto.split(',')[0].trim() : '') === 'https' || new URL(req.url).protocol === 'https:'
Â  const cookie = ${process.env.SESSION_COOKIE_NAME || 'session'}=; Path=/; Max-Age=0; SameSite=Lax; ${isHttps ? 'Secure; ' : ''}HttpOnly
Â  const url = new URL(req.url)
Â  const redirect = url.searchParams.get('redirect') || '/'
Â  return new Response(null, { status: 302, headers: { 'Set-Cookie': cookie, Location: redirect } })
}

// ==== FILE: app\api\auth\me\route.ts ====
import { createHash } from 'crypto'

import { SessionClaims, verifySession } from '../../../../src/lib/jwt'

type UserProfile = {
Â  id: string | number;
Â  username: string;
Â  email: string;
Â  displayName: string;
Â  roles: string[];
Â  avatar_urls?: Record<string, string>;
Â  url?: string;
Â  description?: string;
Â  nickname?: string;
Â  locale?: string;
Â  profile_fields?: Record<string, unknown>;
Â  meta?: Record<string, unknown>;
Â  website?: string;
}

export async function GET(req: Request) {
Â  const cookieHeader = req.headers.get('cookie') || ''
Â  const match = cookieHeader.match(new RegExp(${process.env.SESSION_COOKIE_NAME || 'session'}=([^;]+)))
Â  const token = match?.[1]
Â  if (!token) return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401 })
Â  try {
Â  Â  const claims = await verifySession(token)
Â  	const user: UserProfile = {
Â  Â  Â  id: claims.wpUserId ?? claims.sub,
Â  Â  Â  username: claims.username,
Â  Â  Â  email: claims.email,
Â  Â  Â  displayName: claims.displayName ?? claims.username,
Â  Â  Â  roles: Array.isArray(claims.roles) ? claims.roles : [],
Â  Â  }
Â  Â  // Enrich with live WP profile data (avatar, url, description, updated roles) when possible
Â  Â  const WP = process.env.WP_URL
Â  Â  const wpToken = claims.wpToken
Â  Â  if (WP && wpToken) {
Â  Â  Â  try {
Â  Â  Â  Â  const url = new URL('/wp-json/wp/v2/users/me', WP)
Â  Â  Â  Â  url.searchParams.set('context', 'edit')
Â  // Ask WP for profile_fields (plugin) along with core profile fields
Â  url.searchParams.set('_fields', 'id,slug,name,email,roles,avatar_urls,description,url,locale,nickname,profile_fields,meta')
Â  Â  Â  Â  const res = await fetch(url, { headers: { Authorization: Bearer ${wpToken} }, cache: 'no-store' })
Â  Â  Â  Â  if (res.ok) {
Â  Â  Â  Â  Â  const wp: unknown = await res.json()
Â  Â  Â  Â  Â  if (typeof wp === 'object' && wp !== null) {
Â  Â  Â  Â  Â  	const wpUser = wp as Record<string, unknown>
Â  Â  Â  Â  Â  	if (Array.isArray(wpUser.roles)) user.roles = wpUser.roles as string[]
Â  Â  Â  Â  Â  	if (typeof wpUser.email === 'string') user.email = wpUser.email
Â  Â  Â  Â  Â  	if (typeof wpUser.name === 'string') user.displayName = wpUser.name
Â  Â  Â  Â  Â  	if (typeof wpUser.avatar_urls === 'object' && wpUser.avatar_urls !== null) user.avatar_urls = wpUser.avatar_urls as Record<string, string>
Â  Â  Â  Â  Â  	if (typeof wpUser.url === 'string') user.url = wpUser.url
Â  Â  Â  Â  Â  	if (typeof wpUser.description === 'string') user.description = wpUser.description
Â  Â  Â  Â  Â  	if (typeof wpUser.nickname === 'string') user.nickname = wpUser.nickname
Â  Â  Â  Â  Â  	if (typeof wpUser.locale === 'string') user.locale = wpUser.locale
Â  Â  Â  Â  Â  	// Prefer profile_fields; keep meta for legacy UIs
Â  Â  Â  Â  Â  	if (typeof wpUser.profile_fields === 'object' && wpUser.profile_fields !== null) user.profile_fields = wpUser.profile_fields as Record<string, unknown>
Â  Â  Â  Â  Â  	if (typeof wpUser.meta === 'object' && wpUser.meta !== null) user.meta = wpUser.meta as Record<string, unknown>
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  } catch {
Â  Â  Â  Â  // ignore enrichment failures; return base user
// TODO: implement
Â  Â  Â  }
Â  Â  }
Â  Â  // Compute gravatar fallback if avatar not present but email exists
Â  Â  if (!user.avatar_urls && user.email) {
Â  Â  Â  const md5 = createHash('md5').update(String(user.email).trim().toLowerCase()).digest('hex')
Â  Â  Â  const g = (s: number): string => https://secure.gravatar.com/avatar/${md5}?s=${s}&d=identicon
Â  Â  Â  user.avatar_urls = { '24': g(24), '48': g(48), '96': g(96), '128': g(128) }
Â  Â  }
Â  // Do not synthesize socials anymore; FE derives from user.profile_fields (or meta fallback). Provide website fallback separately.
Â  if (user.url) user.website = user.url
Â  Â  return new Response(JSON.stringify({ user }), { status: 200, headers: { 'Content-Type': 'application/json' } })
Â  } catch {
Â  Â  return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401 })
Â  }
}

// ==== FILE: app\api\auth\register\route.ts ====
import { NextResponse } from 'next/server'
import { z } from 'zod'

import { wpFetch } from '../../../../src/lib/fetcher'
import { logWPError } from '../../../../src/lib/log'
import { CSRF_COOKIE } from '../../../../src/lib/csrf'

const bodySchema = z.object({ email: z.string().email(), password: z.string().min(6), username: z.string().optional() })

export async function POST(req: Request) {
Â  const origin = req.headers.get('origin')
Â  // same-origin only
Â  if (origin && origin !== process.env.NEXT_PUBLIC_SITE_URL) return NextResponse.json({ message: 'Forbidden' }, { status: 403 })

Â  const headerCsrf = req.headers.get('x-csrf-token') || undefined
Â  const cookie = req.headers.get('cookie') || ''
Â  // simple double-submit check
Â  if (!cookie.includes(${CSRF_COOKIE}=) || !headerCsrf) return NextResponse.json({ message: 'Invalid CSRF' }, { status: 403 })

Â  const payload = await req.json().catch(() => null)
Â  const parsed = bodySchema.safeParse(payload)
Â  if (!parsed.success) return NextResponse.json({ message: 'Invalid input', details: parsed.error.format() }, { status: 400 })

Â  try {
Â  Â  const res = await wpFetch('/wp-json/fe-auth/v1/register', { method: 'POST', body: parsed.data })
Â  Â  return NextResponse.json(res, { status: 201 })
Â  } catch (err: unknown) {
Â  Â  const error = err as { status?: number, message?: string, details?: unknown }
Â  Â  // log WP errors for diagnostics
Â  Â  logWPError('register', { status: error.status, statusText: error.message, body: typeof error.details === 'string' ? String(error.details).slice(0, 2000) : JSON.stringify(error.details || '').slice(0, 2000) })
Â  Â  return NextResponse.json({ message: error.message ?? 'Error', details: error.details }, { status: error.status ?? 500 })
Â  }
}

// ==== FILE: app\api\core\endpoints\route.ts ====
import { fetchWithAuth } from '@/lib/fetchWithAuth'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

export async function GET(req: Request) {
Â  if (!WP) return Response.json([], { status: 200 })
Â  // Generic discovery: list all WP REST routes; restrict to fe-* namespaces
Â  const res = await fetchWithAuth(req, ${WP}/wp-json)
Â  try {
Â  Â  const j: unknown = await res.json()
Â  Â  const out: { method: string; route: string }[] = []
Â  Â  if (j && typeof j === 'object' && 'routes' in j && typeof (j as {routes: unknown}).routes === 'object' && (j as {routes: object}).routes) {
Â  Â  Â  for (const [route, meta] of Object.entries((j as {routes: object}).routes)) {
if (typeof meta === 'object' && meta && 'methods' in meta && Array.isArray((meta as {methods: unknown}).methods)) {
const methods: string[] = (meta as {methods: string[]}).methods || []
Â  Â  Â  Â  	methods.forEach(m => out.push({ method: m, route: /api${route}.replace(/^/+/, '/') }))
}
Â  Â  Â  }
Â  Â  }
Â  Â  return Response.json(out)
Â  } catch {
Â  Â  return Response.json([], { status: 200 })
Â  }
}

// ==== FILE: app\api\csrf\route.ts ====
import { NextResponse } from 'next/server'
import { cookies } from 'next/headers'

import { CSRF_COOKIE, generateCsrfToken } from '../../../src/lib/csrf'

export async function GET() {
Â  const store = cookies()
Â  const existing = store.get(CSRF_COOKIE)
Â  if (existing?.value) {
Â  Â  return NextResponse.json({ token: existing.value }, { status: 200 })
Â  }
Â  const token = generateCsrfToken()
Â  const res = NextResponse.json({ token }, { status: 200 })
Â  res.headers.append('Set-Cookie', ${CSRF_COOKIE}=${token}; Path=/; Max-Age=${60 * 60 * 24 * 7}; SameSite=Lax)
Â  return res
}

// ==== FILE: app\api\media-cache\route.ts ====
import { NextRequest } from 'next/server'

import { cacheImage } from '@/lib/mediaCache'

export const runtime = 'nodejs'

export async function GET(req: NextRequest) {
Â  const url = req.nextUrl.searchParams.get('url')
Â  if (!url) return Response.json({ error: 'missing url' }, { status: 400 })
Â  try {
Â  Â  const local = await cacheImage(url)
Â  Â  return Response.json({ url: local })
Â  } catch (e: unknown) {
Â  Â  const message = (e instanceof Error) ? e.message : String(e)
Â  Â  return Response.json({ error: message }, { status: 502 })
Â  }
}

// ==== FILE: app\api\media-cache\image\route.ts ====
import { NextRequest } from 'next/server'

import { cacheImage } from '@/lib/mediaCache'

export const runtime = 'nodejs'

export async function GET(req: NextRequest) {
Â  const url = req.nextUrl.searchParams.get('url')
Â  if (!url) return new Response('missing url', { status: 400 })
Â  try {
Â  Â  const local = await cacheImage(url)
Â  Â  return new Response(null, { status: 302, headers: { Location: local, 'Cache-Control': 'public, max-age=31536000, immutable' } })
Â  } catch {
Â  Â  return new Response('bad upstream', { status: 502 })
Â  }
}

// ==== FILE: app\api\metrics\route.ts ====
import { fetchWithAuth } from '@/lib/fetchWithAuth'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

const WP = (process.env.WP_URL || '').replace(//$/, '')

export async function GET(req: Request) {
Â  if (!WP) return Response.json({ error: 'WP_URL env required' }, { status: 500 })
Â  return fetchWithAuth(req, ${WP}/wp-json/fe-metrics/v1/metrics)
}

export async function POST(req: Request) {
Â  if (!WP) return Response.json({ error: 'WP_URL env required' }, { status: 500 })
Â  const body = await req.text()
Â  return fetchWithAuth(req, ${WP}/wp-json/fe-metrics/v1/metrics, { method: 'POST', body, headers: { 'Content-Type': 'application/json' } })
}

// ==== FILE: app\api\metrics\layout\route.ts ====
import { fetchWithAuth } from '@/lib/fetchWithAuth'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'
const WP = (process.env.WP_URL || '').replace(//$/, '')

export async function GET(req: Request) {
Â  if (!WP) return Response.json({ error: 'WP_URL env required' }, { status: 500 })
Â  return fetchWithAuth(req, ${WP}/wp-json/fe-metrics/v1/layout)
}

export async function POST(req: Request) {
Â  if (!WP) return Response.json({ error: 'WP_URL env required' }, { status: 500 })
Â  const body = await req.text()
Â  return fetchWithAuth(req, ${WP}/wp-json/fe-metrics/v1/layout, { method: 'POST', body, headers: { 'Content-Type': 'application/json' } })
}

export async function DELETE(req: Request) {
Â  if (!WP) return Response.json({ error: 'WP_URL env required' }, { status: 500 })
Â  return fetchWithAuth(req, ${WP}/wp-json/fe-metrics/v1/layout, { method: 'DELETE' })
}

// ==== FILE: app\api\metrics\layout\default\route.ts ====
import { fetchWithAuth } from '@/lib/fetchWithAuth'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'
const WP = (process.env.WP_URL || '').replace(//$/, '')

export async function POST(req: Request) {
Â  if (!WP) return Response.json({ error: 'WP_URL env required' }, { status: 500 })
Â  const body = await req.text()
Â  return fetchWithAuth(req, ${WP}/wp-json/fe-metrics/v1/layout/default, { method: 'POST', body, headers: { 'Content-Type': 'application/json' } })
}

// ==== FILE: app\api\metrics\variables\route.ts ====
import { fetchWithAuth } from '@/lib/fetchWithAuth'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'
const WP = (process.env.WP_URL || '').replace(//$/, '')

export async function GET(_req: Request) {
Â  // Virtual vars can be enriched on FE; for now proxy a WP endpoint if present, else return a basic set
Â  if (WP) {
Â  Â  try { return await fetchWithAuth(_req, ${WP}/wp-json/fe-metrics/v1/variables) } catch {
Â  Â  Â  // TODO: implement metrics variable upstream fallback logging
Â  Â  }
Â  }
Â  return Response.json([
Â  Â  { name: 'views', endpoint: '/api/analytics/views' },
Â  Â  { name: 'sessions', endpoint: '/api/analytics/sessions' },
Â  Â  { name: 'comments', endpoint: '/api/wp/comments' },
Â  Â  { name: 'users', endpoint: '/api/wp/users' },
Â  ])
}

// ==== FILE: app\api\metrics[id]\route.ts ====
import { fetchWithAuth } from '@/lib/fetchWithAuth'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'
const WP = (process.env.WP_URL || '').replace(//$/, '')

export async function GET(req: Request, { params }: { params: { id: string } }) {
Â  if (!WP) return Response.json({ error: 'WP_URL env required' }, { status: 500 })
Â  return fetchWithAuth(req, ${WP}/wp-json/fe-metrics/v1/metrics/${params.id})
}

export async function PUT(req: Request, { params }: { params: { id: string } }) {
Â  if (!WP) return Response.json({ error: 'WP_URL env required' }, { status: 500 })
Â  const body = await req.text()
Â  return fetchWithAuth(req, ${WP}/wp-json/fe-metrics/v1/metrics/${params.id}, { method: 'PUT', body, headers: { 'Content-Type': 'application/json' } })
}

export async function DELETE(req: Request, { params }: { params: { id: string } }) {
Â  if (!WP) return Response.json({ error: 'WP_URL env required' }, { status: 500 })
Â  return fetchWithAuth(req, ${WP}/wp-json/fe-metrics/v1/metrics/${params.id}, { method: 'DELETE' })
}

// ==== FILE: app\api\metrics[id]\eval\route.ts ====
import { fetchWithAuth } from '@/lib/fetchWithAuth'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'
const WP = (process.env.WP_URL || '').replace(//$/, '')

export async function GET(req: Request, { params }: { params: { id: string } }) {
Â  if (!WP) return Response.json({ error: 'WP_URL env required' }, { status: 500 })
Â  return fetchWithAuth(req, ${WP}/wp-json/fe-metrics/v1/metrics/${params.id}/eval)
}

// ==== FILE: app\api\revalidate\route.ts ====
import { revalidateTag } from 'next/cache'

export async function POST(req: Request) {
Â  let body: unknown = {}
Â  try { body = await req.json() } catch (_e: unknown) { /* ignore */ }
Â  const url = new URL(req.url)
Â  const b = (typeof body === 'object' && body) ? (body as Record<string, unknown>) : {}
Â  const secret = url.searchParams.get('secret') || b?.secret
Â  if (secret !== process.env.NEXT_REVALIDATE_SECRET) return new Response('Forbidden', { status: 403 })

Â  const { slug, page, taxonomy, all } = b || {}
Â  const revalidated: string[] = []

Â  try {
Â  Â  // Prefer tag-based revalidation if available
Â  Â  if (typeof revalidateTag === 'function') {
Â  Â  Â  if (all) {
Â  Â  Â  Â  // broad sweep
Â  Â  Â  Â  revalidateTag('wp:posts')
Â  Â  Â  Â  revalidated.push('/')
Â  Â  Â  Â  revalidated.push('/blogs')
Â  Â  Â  }
Â  Â  Â  // always refresh list on demand
Â  Â  Â  revalidateTag('wp:posts')
Â  Â  Â  revalidated.push('/')
Â  Â  Â  if (typeof slug === 'string' && slug) {
Â  Â  Â  Â  revalidateTag(wp:post:${slug})
Â  Â  Â  Â  revalidated.push(/blogs/${slug})
Â  Â  Â  }
Â  Â  Â  if (typeof page === 'string' && page) {
Â  Â  Â  Â  revalidateTag(wp:page:${page})
Â  Â  Â  Â  revalidated.push(/pages/${page})
Â  Â  Â  }
Â  Â  Â  if (typeof taxonomy === 'string' && taxonomy) {
Â  Â  Â  Â  // optional future taxonomy tagging, kept for parity
Â  Â  Â  Â  revalidateTag(wp:tax:${taxonomy})
Â  Â  Â  }
Â  Â  Â  return new Response(JSON.stringify({ revalidated, now: Date.now() }), { status: 200, headers: { 'Content-Type': 'application/json' } })
Â  Â  }

Â  Â  // Fallback: return the list for an external revalidator to act on
Â  Â  revalidated.push('/')
Â  Â  revalidated.push('/blogs')
Â  Â  if (typeof slug === 'string' && slug) revalidated.push(/blogs/${slug})
Â  return new Response(JSON.stringify({ revalidated, now: Date.now() }), { status: 200, headers: { 'Content-Type': 'application/json' } })
Â  } catch (e: unknown) {
Â  Â  const msg = (e && typeof e === 'object' && 'message' in e) ? String((e as Error).message) : String(e)
Â  return new Response(JSON.stringify({ message: msg || 'fail', error: String(e) }), { status: 500, headers: { 'Content-Type': 'application/json' } })
Â  }
}

// ==== FILE: app\api\roles\matrix\route.ts ====
import { NextRequest } from 'next/server'
import { cookies } from 'next/headers'

import { SessionClaims, verifySession } from '@/lib/jwt'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

// Minimal roles matrix focused on editing capabilities
// This can be extended or wired to WP capabilities if needed
export async function GET(_req: NextRequest) {
Â  const cookieStore = cookies()
Â  const sessionCookie = cookieStore.get(process.env.SESSION_COOKIE_NAME ?? 'session')
Â  let roles: string[] = []
Â  if (sessionCookie?.value) {
Â  Â  try {
Â  Â  Â  const claims = await verifySession(sessionCookie.value)
Â  Â  Â  roles = claims?.roles || []
Â  Â  } catch {
// TODO: implement
}
Â  }
Â  const matrix = {
Â  Â  roles,
Â  Â  can: {
Â  Â  Â  posts: {
Â  Â  Â  Â  create: roles.some(r => ['author','editor','administrator'].includes(r)),
Â  Â  Â  Â  edit: roles.some(r => ['author','editor','administrator'].includes(r)),
Â  Â  Â  Â  delete: roles.some(r => ['editor','administrator'].includes(r)),
Â  Â  Â  Â  publish: roles.some(r => ['editor','administrator'].includes(r)),
Â  Â  Â  Â  requestPublish: roles.some(r => ['author','editor','administrator'].includes(r)),
Â  Â  Â  }
Â  Â  }
Â  }
Â  return Response.json(matrix, { headers: { 'Cache-Control': 'no-store' } })
}

// ==== FILE: app\api\test\route.ts ====
export const runtime = 'nodejs'

export async function GET() {
Â  return Response.json({ status: 'ok' })
}

// ==== FILE: app\api\test-wp\route.ts ====
export async function GET() {
Â  try {
Â  Â  console.log('Testing WordPress connection...')
Â  Â Â 
Â  Â  // Test basic WordPress REST API
Â  Â  const wpUrl = process.env.WP_URL || 'http://example.com'
Â  Â  console.log('WordPress URL:', wpUrl)
Â  Â Â 
Â  Â  const testResponse = await fetch(${wpUrl}/wp-json/wp/v2/posts?per_page=1, {
Â  Â  Â  method: 'GET',
Â  Â  Â  headers: {
Â  Â  Â  Â  'User-Agent': 'Next.js/15.3.3'
Â  Â  Â  }
Â  Â  })
Â  Â Â 
Â  Â  console.log('Basic API Response:', testResponse.status, testResponse.statusText)
Â  Â Â 
Â  Â  if (!testResponse.ok) {
Â  Â  Â  const errorText = await testResponse.text()
Â  Â  Â  console.log('Basic API Error:', errorText)
Â  Â  Â  return new Response(JSON.stringify({Â 
Â  Â  Â  Â  error: 'WordPress basic API failed',Â 
Â  Â  Â  Â  status: testResponse.status,
Â  Â  Â  Â  statusText: testResponse.statusText,
Â  Â  Â  Â  details: errorText
Â  Â  Â  }), {Â 
Â  Â  Â  Â  status: 500,Â 
Â  Â  Â  Â  headers: { 'Content-Type': 'application/json' }Â 
Â  Â  Â  })
Â  Â  }
Â  Â Â 
Â  Â  const basicData = await testResponse.json()
Â  Â  console.log('Basic API Success, posts count:', Array.isArray(basicData) ? basicData.length : 'not array')
Â  Â Â 
Â  Â  // Test JWT endpoint availability
Â  Â  const jwtResponse = await fetch(${wpUrl}/wp-json/jwt-auth/v1/token, {
Â  Â  Â  method: 'POST',
Â  Â  Â  headers: {
Â  Â  Â  Â  'Content-Type': 'application/json',
Â  Â  Â  Â  'User-Agent': 'Next.js/15.3.3'
Â  Â  Â  },
Â  Â  Â  body: JSON.stringify({ username: 'test', password: 'test' })
Â  Â  })
Â  Â Â 
Â  Â  console.log('JWT Response:', jwtResponse.status, jwtResponse.statusText)
Â  Â  const jwtData = await jwtResponse.json()
Â  Â  console.log('JWT Response Data:', jwtData)
Â  Â Â 
Â  Â  return new Response(JSON.stringify({Â 
Â  Â  Â  success: true,
Â  Â  Â  wpUrl,
Â  Â  Â  basicApiStatus: testResponse.status,
Â  Â  Â  jwtApiStatus: jwtResponse.status,
Â  Â  Â  jwtResponse: jwtData,
Â  Â  Â  message: 'WordPress connection test completed'
Â  Â  }), {Â 
Â  Â  Â  status: 200,Â 
Â  Â  Â  headers: { 'Content-Type': 'application/json' }Â 
Â  Â  })
Â  Â Â 
Â  } catch (error: unknown) {
Â  Â  const err = error as Error;
Â  Â  console.error('WordPress connection test failed:', err)
Â  Â  return new Response(JSON.stringify({Â 
Â  Â  Â  error: 'Connection test failed',Â 
Â  Â  Â  details: err.message,
Â  Â  Â  stack: err.stack
Â  Â  }), {Â 
Â  Â  Â  status: 500,Â 
Â  Â  Â  headers: { 'Content-Type': 'application/json' }Â 
Â  Â  })
Â  }
}

// ==== FILE: app\api\wp\bookmarks\route.ts ====
export const dynamic = 'force-dynamic'
export const runtime = 'nodejs'

import { fetchWithAuth, MissingWpTokenError } from '@/lib/fetchWithAuth'

function getWpBase() {
Â  const WP = process.env.WP_URL || process.env.NEXT_PUBLIC_WP_URL
Â  if (!WP) throw new Error('WP_URL env required')
Â  return WP.replace(//$/, '')
}

export async function GET(req: Request) {
Â  try {
Â  Â  const { searchParams } = new URL(req.url)
Â  Â  const postId = searchParams.get('postId') || searchParams.get('post_id')
Â  Â  const expand = searchParams.get('expand')
Â  Â  const base = getWpBase()
Â  Â  if (postId) {
Â  Â  Â  const url = new URL('/wp-json/fe-auth/v1/bookmarks/check', base)
Â  Â  Â  url.searchParams.set('post_id', String(postId))
Â  Â  Â  return await fetchWithAuth(req, url.toString())
Â  Â  }
Â  Â  const url = new URL('/wp-json/fe-auth/v1/bookmarks', base)
Â  Â  if (expand) url.searchParams.set('expand', expand)
Â  Â  return await fetchWithAuth(req, url.toString())
Â  } catch (e: unknown) {
Â  Â  if (e instanceof MissingWpTokenError) {
Â  Â  Â  return new Response(JSON.stringify({ error: 'unauthorized', message: 'Login required to use bookmarks' }), { status: 401, headers: { 'Content-Type': 'application/json' } })
Â  Â  }
Â  Â  console.error('bookmarks.GET unexpected error:', e)
const message = (e instanceof Error) ? e.message : String(e)
Â  Â  return new Response(JSON.stringify({ error: 'server_error', detail: message }), { status: 500, headers: { 'Content-Type': 'application/json' } })
Â  }
}

export async function POST(req: Request) {
Â  try {
Â  Â  let body: unknown;
Â  Â  try { body = await req.json() } catch { body = null }
const postIdNum = (body && typeof body === 'object') ? ((body as Record<string, unknown>).postId ?? (body as Record<string, unknown>).post_id) : 0
Â  Â  const postId = Number(postIdNum ?? 0)
Â  Â  if (!postId || !Number.isFinite(postId)) {
Â  Â  Â  return new Response(JSON.stringify({ error: 'postId required' }), { status: 400, headers: { 'Content-Type': 'application/json' } })
Â  Â  }
Â  Â  const base = getWpBase()
Â  Â  const url = new URL('/wp-json/fe-auth/v1/bookmarks/toggle', base)
Â  Â  return await fetchWithAuth(req, url.toString(), {
Â  Â  Â  method: 'POST',
Â  Â  Â  headers: { 'Content-Type': 'application/json' },
Â  Â  Â  body: JSON.stringify({ post_id: postId }),
Â  Â  })
Â  } catch (e: unknown) {
Â  Â  if (e instanceof MissingWpTokenError) {
Â  Â  Â  return new Response(JSON.stringify({ error: 'unauthorized', message: 'Login required to save bookmarks' }), { status: 401, headers: { 'Content-Type': 'application/json' } })
Â  Â  }
Â  Â  console.error('bookmarks.POST unexpected error:', e)
const message = (e instanceof Error) ? e.message : String(e)
Â  Â  return new Response(JSON.stringify({ error: 'server_error', detail: message }), { status: 500, headers: { 'Content-Type': 'application/json' } })
Â  }
}

// ==== FILE: app\api\wp\comments\route.ts ====
// Define Next.js route config locally so it's recognized (avoid re-exporting these)
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

// Re-export handlers from the shared implementation
export { GET, POST } from '../../../../src/app/api/wp/comments/route'

// ==== FILE: app\api\wp\comments\bulk\route.ts ====
import { fetchWithAuth } from '@/lib/fetchWithAuth'
import { apiMap } from '@/lib/wpAPIMap'
import { requireAccess } from '@/lib/requireAccess'

export const runtime = 'nodejs'

export async function POST(req: Request) {
Â  await requireAccess({ path: '/api/wp/comments/[id]', method: 'PATCH', action: 'moderate' })
Â  // Proxy to MU endpoint defined in apiMap.comments.bulk
Â  return fetchWithAuth(req, apiMap.comments.bulk, { method: 'POST', body: await req.text(), headers: { 'Content-Type': 'application/json' } })
}

// ==== FILE: app\api\wp\media\route.ts ====
import { fetchWithAuth } from '@/lib/fetchWithAuth'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'
const WP = (process.env.WP_URL || '').replace(//$/, '')

export async function GET(req: Request) {
Â  if (!WP) return Response.json({ error: 'WP_URL env required' }, { status: 500 })
Â  const url = new URL(${WP}/wp-json/fe-media/v1/media)
Â  const inUrl = new URL(req.url)
Â  inUrl.searchParams.forEach((v, k) => url.searchParams.set(k, v))
Â  return fetchWithAuth(req, url.toString())
}

export async function POST(req: Request) {
Â  if (!WP) return Response.json({ error: 'WP_URL env required' }, { status: 500 })
Â  // Pass through multipart form-data
Â  const body = await req.arrayBuffer()
Â  const headers: HeadersInit = { 'Content-Type': req.headers.get('content-type') || 'application/octet-stream' }
Â  return fetchWithAuth(req, ${WP}/wp-json/fe-media/v1/media, { method: 'POST', body, headers })
}

// ==== FILE: app\api\wp\media\count\route.ts ====
import { getWpTokenFromRequest } from '@/lib/fetchWithAuth'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

export async function GET(req: Request) {
Â  const WP = process.env.WP_URL
Â  if (!WP) return Response.json({ error: 'WP_URL env required' }, { status: 500 })
Â  const inUrl = new URL(req.url)
Â  const mediaType = inUrl.searchParams.get('media_type') || ''
Â  const u = new URL('/wp-json/wp/v2/media', WP)
Â  u.searchParams.set('per_page', '1')
Â  if (mediaType) u.searchParams.set('media_type', mediaType)

Â  const token = await getWpTokenFromRequest(req)
Â  const headers: Record<string, string> = {
Â  Â  'User-Agent': 'techoblivion-fe/1.0',
Â  Â  'Accept': 'application/json',
Â  }
Â  if (token) headers.Authorization = Bearer ${token}

Â  const res = await fetch(u.toString(), { cache: 'no-store', headers })
Â  const total = res.headers.get('x-wp-total')
Â  return Response.json({ count: total ? Number(total) : (res.ok ? 0 : null) }, { status: res.ok ? 200 : res.status })
}

// ==== FILE: app\api\wp\media[...slug]\route.ts ====
import type { NextRequest } from 'next/server'
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

export async function GET(_req: NextRequest, { params }: { params: { slug?: string[]; path?: string[] } }) {
Â  const segs = (params?.slug ?? params?.path ?? []) as string[]
Â  if (!Array.isArray(segs) || segs.length === 0) {
Â  Â  return new Response('Bad path', { status: 400 })
Â  }
Â  const WP = (process.env.WP_URL || 'http://example.com').replace(//+$/, '')
Â  let origin = ${WP}/${segs.join('/')}
Â  if (segs[0] === 'absolute') {
Â  Â  const encoded = segs.slice(1).join('/')
Â  Â  try {
Â  Â  Â  const full = decodeURIComponent(encoded)
Â  Â  Â  const u = new URL(full)
Â  Â  Â  if (u.protocol === 'http:' || u.protocol === 'https:') origin = full
Â  Â  } catch {
// TODO: implement
}
Â  }

Â  const headers: Record<string, string> = {
Â  Â  Accept: 'image/,/*;q=0.8',
Â  Â  'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36',
Â  Â  Referer: 'http://example.com/',
Â  }
Â  let upstream: Response
Â  try {
Â  Â  upstream = await fetch(origin, { cache: 'no-store', headers })
Â  } catch (_err: unknown) {
Â  Â  return placeholder('upstream-fetch-error')
Â  }
Â  if (!upstream.ok) {
Â  Â  return upstream.status === 404 ? new Response('Not found', { status: 404 }) : placeholder(upstream-status-${upstream.status})
Â  }
Â  const ct = upstream.headers.get('content-type')?.toLowerCase() ?? ''
Â  const ab = await upstream.arrayBuffer()
Â  if (!ct.startsWith('image/')) {
Â  Â  return placeholder('bad-content-type', { 'X-Upstream-Content-Type': ct || 'unknown' })
Â  }
Â  return new Response(ab, { headers: { 'Content-Type': ct || 'application/octet-stream', 'Cache-Control': 'public, max-age=31536000, immutable' } })
}

function placeholder(reason: string, extra?: Record<string, string>) {
Â  const b64 = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMBA6m+Vb8AAAAASUVORK5CYII='
Â  const body = Buffer.from(b64, 'base64')
Â  return new Response(body, { status: 200, headers: { 'Content-Type': 'image/png', 'Cache-Control': 'public, max-age=300', 'X-Proxy-Status': reason, ...(extra || {}) } })
}

// ==== FILE: app\api\wp\media[id]\route.ts ====
import { fetchWithAuth } from '@/lib/fetchWithAuth'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'
const WP = (process.env.WP_URL || '').replace(//$/, '')

export async function DELETE(req: Request, { params }: { params: { id: string } }) {
Â  if (!WP) return Response.json({ error: 'WP_URL env required' }, { status: 500 })
Â  return fetchWithAuth(req, ${WP}/wp-json/fe-media/v1/media/${params.id}, { method: 'DELETE' })
}

// ==== FILE: app\api\wp\popular\route.ts ====
import { NextRequest, NextResponse } from 'next/server'

export const dynamic = 'force-dynamic'
export const runtime = 'nodejs'

type PopularItem = { id: number } | { post_id: number }
type WpPost = {
id: number;
slug: string;
title: { rendered: string } | string;
excerpt: { rendered: string };
_embedded?: {
'wp:featuredmedia'?: { source_url: string }[];
author?: { name: string }[];
};
featured_media_url?: string;
jetpack_featured_media_url?: string;
date: string;
}

export async function GET(_req: NextRequest) {
Â  const WP = process.env.WP_URL || process.env.NEXT_PUBLIC_WP_URL
Â  if (!WP) return NextResponse.json({ error: 'WP_URL missing' }, { status: 500 })

Â  const { searchParams } = new URL(_req.url)
Â  const range = (searchParams.get('range') || 'month').toLowerCase() // day|week|month|all
Â  const limit = Math.min(Math.max(Number(searchParams.get('limit') || 6), 1), 12)

Â  // Try WordPress Popular Posts REST API first
Â  const base = new URL('/wp-json/wordpress-popular-posts', WP.replace(//$/, ''))
Â  const wppUrl = new URL('/v1/popular-posts', base)
Â  wppUrl.searchParams.set('range', ['day','week','month','all'].includes(range) ? range : 'month')
Â  wppUrl.searchParams.set('limit', String(limit))

Â  let ids: number[] = []
Â  try {
Â  Â  const wppRes = await fetch(wppUrl.toString(), { headers: { Accept: 'application/json' }, next: { revalidate: 600 } })
Â  Â  if (wppRes.ok) {
Â  Â  Â  const items = (await wppRes.json()) as PopularItem[]
Â  Â  Â  ids = (items || []).map((i) => Number('id' in i ? i.id : i.post_id)).filter((n) => Number.isFinite(n))
Â  Â  }
Â  } catch {
// TODO: implement
}

Â  // Fallback: empty or failed -> use latest posts as a reasonable default
Â  let posts: WpPost[] = []
Â  try {
Â  Â  if (ids.length) {
Â  Â  Â  const detailsUrl = new URL('/wp-json/wp/v2/posts', WP)
Â  Â  Â  detailsUrl.searchParams.set('include', ids.join(','))
Â  Â  Â  detailsUrl.searchParams.set('_embed', '1')
Â  Â  Â  detailsUrl.searchParams.set('per_page', String(limit))
Â  Â  Â  const res = await fetch(detailsUrl.toString(), { headers: { Accept: 'application/json' }, next: { revalidate: 600 } })
Â  Â  Â  if (res.ok) {
Â  Â  Â  Â  posts = await res.json()
Â  Â  Â  Â  // Keep the order of ids from WPP
Â  Â  Â  Â  const order = new Map(ids.map((id, idx) => [id, idx]))
Â  Â  Â  Â  posts.sort((a, b) => (order.get(a.id) ?? 0) - (order.get(b.id) ?? 0))
Â  Â  Â  }
Â  Â  } else {
Â  Â  Â  const latestUrl = new URL('/wp-json/wp/v2/posts', WP)
Â  Â  Â  latestUrl.searchParams.set('_embed', '1')
Â  Â  Â  latestUrl.searchParams.set('per_page', String(limit))
Â  Â  Â  const res = await fetch(latestUrl.toString(), { headers: { Accept: 'application/json' }, next: { revalidate: 300 } })
Â  Â  Â  if (res.ok) posts = await res.json()
Â  Â  }
Â  } catch (e) {
Â  Â  return NextResponse.json({ error: 'Upstream error', detail: String(e) }, { status: 502 })
Â  }

Â  const simplified = posts.map((p) => ({
Â  Â  id: p.id,
Â  Â  slug: p.slug,
Â  Â  title: typeof p.title === 'string' ? p.title : p.title?.rendered || '',
Â  Â  excerpt: (p.excerpt?.rendered || '').replace(/<[^\>]+>/g, ''),
Â  Â  featuredImage: p._embedded?.['wp:featuredmedia']?.[0]?.source_url || p.featured_media_url || p.jetpack_featured_media_url || '',
Â  Â  authorName: p._embedded?.author?.[0]?.name || '',
Â  Â  date: p.date || '',
Â  }))
Â  return NextResponse.json(simplified, { status: 200, headers: { 'Cache-Control': 'public, max-age=300, stale-while-revalidate=600' } })
}

// ==== FILE: app\api\wp\posts\route.ts ====
// Define Next.js route config locally so it's recognized
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

// Re-export handlers from the shared implementation
export { GET, POST, PATCH } from '../../../../src/app/api/wp/posts/route'

import { NextRequest } from 'next/server'

export async function DELETE(req: NextRequest) {
const upstream = process.env.WP_URL || process.env.WP_BASE
if (!upstream) return new Response(JSON.stringify({ error: 'WP_URL/WP_BASE env required' }), { status: 500 })
const url = new URL(req.url)
const id = url.searchParams.get('id')
if (!id) return new Response(JSON.stringify({ error: 'Missing id' }), { status: 400 })

// Forward Authorization if present, else fallback
const authHeader = req.headers.get('authorization') || (process.env.WP_AUTH_TOKEN ? `Bearer ${process.env.WP_AUTH_TOKEN}` : undefined)
const controller = new AbortController()
const to = setTimeout(() => controller.abort(), 10_000)
try {
	const res = await fetch(new URL(`/wp-json/wp/v2/posts/${id}`, upstream), {
		method: 'DELETE',
		headers: { ...(authHeader ? { Authorization: authHeader } : {}), 'Content-Type': 'application/json' },
		signal: controller.signal,
	})
	const text = await res.text()
	return new Response(text, { status: res.status, headers: { 'Content-Type': res.headers.get('Content-Type') || 'application/json' } })
} catch (e: unknown) {
	const err = e as Error
	const msg = err?.name === 'AbortError' ? 'Upstream timeout' : (err?.message || 'Upstream error')
	return new Response(JSON.stringify({ error: msg }), { status: 504 })
} finally {
	clearTimeout(to)
}
}

// ==== FILE: app\api\wp\posts\count\route.ts ====
import { getWpTokenFromRequest } from '@/lib/fetchWithAuth'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

export async function GET(req: Request) {
Â  const WP = process.env.WP_URL
Â  if (!WP) return Response.json({ error: 'WP_URL env required' }, { status: 500 })
Â  const inUrl = new URL(req.url)
Â  const status = inUrl.searchParams.get('status') || ''
Â  const u = new URL('/wp-json/wp/v2/posts', WP)
Â  u.searchParams.set('per_page', '1')
Â  if (status) u.searchParams.set('status', status)

Â  // Include auth when available; required for non-public statuses like draft/pending
Â  const token = await getWpTokenFromRequest(req)
Â  const headers: Record<string, string> = {
Â  Â  'User-Agent': 'techoblivion-fe/1.0',
Â  Â  'Accept': 'application/json',
Â  }
Â  if (token) headers.Authorization = Bearer ${token}
Â  if (!token && status && status !== 'publish') {
Â  Â  return Response.json({ error: 'unauthorized', message: 'Login required for non-public post statuses' }, { status: 401 })
Â  }

Â  const res = await fetch(u.toString(), { cache: 'no-store', headers })
Â  const total = res.headers.get('x-wp-total')
Â  return Response.json({ count: total ? Number(total) : (res.ok ? 0 : null) }, { status: res.ok ? 200 : res.status })
}

// ==== FILE: app\api\wp\related\route.ts ====
import { NextRequest, NextResponse } from 'next/server'

export const dynamic = 'force-dynamic'

type WpPostSimple = {
id: number;
slug: string;
title?: {
rendered?: string;
};
}

export async function GET(req: NextRequest) {
Â  const WP = process.env.WP_URL ?? ''
Â  if (!WP) return NextResponse.json({ error: 'WP_URL missing' }, { status: 500 })

Â  const { searchParams } = new URL(req.url)
Â  const categories = searchParams.get('categories') || ''
Â  const tags = searchParams.get('tags') || ''
Â  const exclude = searchParams.get('exclude') || ''
Â  const per_page = searchParams.get('per_page') || '5'

Â  const url = new URL('/wp-json/wp/v2/posts', WP)
Â  url.searchParams.set('_embed', '1')
Â  if (categories) url.searchParams.set('categories', categories)
Â  if (tags) url.searchParams.set('tags', tags)
Â  if (exclude) url.searchParams.set('exclude', exclude)
Â  url.searchParams.set('per_page', per_page)

Â  const res = await fetch(url.toString(), {
Â  Â  headers: { 'Accept': 'application/json', 'User-Agent': 'techoblivion-proxy/1.0 (+https://techoblivion.in)' },
Â  Â  next: { revalidate: Number(process.env.WP_CACHE_TTL || 300) },
Â  })
Â  if (!res.ok) {
Â  Â  const body = await res.text()
Â  Â  return NextResponse.json({ error: 'Upstream error', status: res.status, message: body }, { status: 502 })
Â  }
Â  const data: unknown = await res.json()
Â  const simplified = (Array.isArray(data) ? data as WpPostSimple[] : []).map(p => ({ id: p.id, slug: p.slug, title: { rendered: p.title?.rendered || '' } }))
Â  return NextResponse.json(simplified, { status: 200 })
}

// ==== FILE: app\api\wp\search\route.ts ====
import { NextRequest, NextResponse } from 'next/server'

export const dynamic = 'force-dynamic'

export async function GET(req: NextRequest) {
Â  const WP = process.env.WP_URL ?? ''
Â  if (!WP) return NextResponse.json({ error: 'WP_URL missing' }, { status: 500 })
Â  const { searchParams } = new URL(req.url)
Â  const q = searchParams.get('q') || ''
Â  if (!q) return NextResponse.json([], { status: 200 })

Â  const url = new URL('/wp-json/wp/v2/posts', WP)
Â  url.searchParams.set('_embed', '0')
Â  url.searchParams.set('search', q)
Â  url.searchParams.set('per_page', '10')
Â  const res = await fetch(url.toString(), {
Â  Â  headers: { 'Accept': 'application/json', 'User-Agent': 'techoblivion-proxy/1.0 (+https://techoblivion.in)' },
Â  Â  next: { revalidate: Number(process.env.WP_CACHE_TTL || 300) },
Â  })
Â  if (!res.ok) {
Â  Â  const body = await res.text().catch(() => '')
Â  Â  return NextResponse.json({ error: 'Upstream error', status: res.status, message: body }, { status: 502 })
Â  }
Â  const data = await res.json()
Â  return NextResponse.json(data, { status: 200 })
}

// ==== FILE: app\api\wp\site-health\background-updates\route.ts ====
import { apiMap } from '@/lib/wpAPIMap'
import { fetchWithAuth } from '@/lib/fetchWithAuth'

export const runtime = 'nodejs'

export async function GET(req: Request) {
Â  return fetchWithAuth(req, apiMap.siteHealth.backgroundUpdates)
}

// ==== FILE: app\api\wp\site-health\directory-sizes\route.ts ====
import { apiMap } from '@/lib/wpAPIMap'
import { fetchWithAuth } from '@/lib/fetchWithAuth'

export const runtime = 'nodejs'

export async function GET(req: Request) {
Â  return fetchWithAuth(req, apiMap.siteHealth.directorySizes)
}

// ==== FILE: app\api\wp\track-view\route.ts ====
export const dynamic = 'force-dynamic'
export const runtime = 'nodejs'

export async function POST(req: Request) {
Â  const WP = process.env.WP_URL || process.env.NEXT_PUBLIC_WP_URL
Â  if (!WP) return new Response(JSON.stringify({ error: 'WP_URL env required' }), { status: 500 })
Â  let body: unknown;
Â  try { body = await req.json() } catch { body = null }
const postIdNum = (body && typeof body === 'object') ? ((body as Record<string, unknown>).postId ?? (body as Record<string, unknown>).post_id) : 0;
Â  const postId = Number(postIdNum ?? 0)
Â  if (!postId || !Number.isFinite(postId)) {
Â  Â  return new Response(JSON.stringify({ error: 'postId required' }), { status: 400 })
Â  }
Â  const url = new URL('/wp-json/fe-auth/v1/track-view', WP.replace(//$/, ''))
Â  try {
Â  Â  const incomingCookies = req.headers.get('cookie') || ''
Â  Â  const ua = req.headers.get('user-agent') || 'techoblivion-next-proxy'
Â  Â  const ip = (req.headers.get('x-forwarded-for') || '').split(',')[0]?.trim()
Â  Â  const r = await fetch(url.toString(), {
Â  Â  Â  method: 'POST',
Â  Â  Â  headers: {
Â  Â  Â  Â  'Content-Type': 'application/json',
Â  Â  Â  Â  Accept: 'application/json',
Â  Â  Â  Â  // Forward cookies to allow WP to detect logged-in users
Â  Â  Â  Â  ...(incomingCookies ? { cookie: incomingCookies } : {}),
Â  Â  Â  Â  'User-Agent': ua,
Â  Â  Â  Â  ...(ip ? { 'X-Forwarded-For': ip } : {}),
Â  Â  Â  },
Â  Â  Â  cache: 'no-store',
Â  Â  Â  body: JSON.stringify({ post_id: postId })
Â  Â  })
Â  Â  const text = await r.text()
Â  Â  if (!r.ok) {
Â  Â  Â  return new Response(text || JSON.stringify({ error: 'wp error' }), { status: r.status })
Â  Â  }
Â  Â  return new Response(text || '{}', { status: 200, headers: { 'Content-Type': 'application/json' } })
Â  } catch (e: unknown) {
Â  Â  return new Response(JSON.stringify({ error: 'upstream error', detail: String(e) }), { status: 502 })
Â  }
}

// ==== FILE: app\api\wp\users\route.ts ====
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

import { createHmac } from 'crypto'

type LiteUser = {
Â  id: number
Â  slug: string
Â  name?: string
Â  description?: string
Â  avatar_urls?: Record<string, string>
Â  social?: { twitter: string | null; linkedin: string | null; github: string | null }
}

function normalizeUrl(u?: string | null): string | null {
Â  if (!u) return null
Â  const s = String(u).trim()
Â  if (!s) return null
Â  if (/^https?:///i.test(s)) return s
Â  return https://${s}
}

function deriveSocial(u: unknown): { twitter: string | null; linkedin: string | null; github: string | null } {
Â  if (u && typeof u === 'object') {
Â  Â  const obj = u as Record<string, unknown>
Â  Â  const social = obj.social
Â  Â  if (social && typeof social === 'object') {
Â  Â  Â  const s = social as Record<string, unknown>
Â  Â  Â  return {
Â  Â  Â  Â  twitter: normalizeUrl(typeof s.twitter === 'string' ? s.twitter : null),
Â  Â  Â  Â  linkedin: normalizeUrl(typeof s.linkedin === 'string' ? s.linkedin : null),
Â  Â  Â  Â  github: normalizeUrl(typeof s.github === 'string' ? s.github : null),
Â  Â  Â  }
Â  Â  }
Â  Â  const pf = typeof obj.profile_fields === 'object' && obj.profile_fields
Â  Â  Â  ? (obj.profile_fields as Record<string, unknown>)
Â  Â  Â  : null
Â  Â  const get = (k: string) => (pf && typeof pf[k] === 'string') ? (pf[k] as string) : undefined
Â  Â  const tw = (typeof obj.twitter_url === 'string' ? obj.twitter_url : undefined) || get('twitter_url') || get('twitter') || get('x')
Â  Â  const ln = (typeof obj.linkedin_url === 'string' ? obj.linkedin_url : undefined) || get('linkedin_url') || get('linkedin')
Â  Â  const gh = (typeof obj.github_url === 'string' ? obj.github_url : undefined) || get('github_url') || get('github')
Â  Â  return { twitter: normalizeUrl(tw || null), linkedin: normalizeUrl(ln || null), github: normalizeUrl(gh || null) }
Â  }
Â  return { twitter: null, linkedin: null, github: null }
}

function sanitize(u: unknown): LiteUser {
Â  const obj = (u && typeof u === 'object') ? (u as Record<string, unknown>) : {}
Â  const idRaw = obj.id
Â  const slugRaw = (obj.slug ?? obj.user_nicename)
Â  const nameRaw = (obj.name ?? obj.display_name)
Â  const descRaw = obj.description
Â  const avatarRaw = obj.avatar_urls
Â  return {
Â  Â  id: Number(typeof idRaw === 'number' ? idRaw : parseInt(String(idRaw ?? 0), 10) || 0),
Â  Â  slug: String(typeof slugRaw === 'string' ? slugRaw : ''),
Â  Â  name: typeof nameRaw === 'string' ? nameRaw : '',
Â  Â  description: typeof descRaw === 'string' ? descRaw : '',
Â  Â  avatar_urls: (avatarRaw && typeof avatarRaw === 'object') ? (avatarRaw as Record<string, string>) : {},
Â  Â  social: deriveSocial(u),
Â  }
}

function chunk<T>(arr: T[], size = 100): T[][] {
Â  const out: T[][] = []
Â  for (let i = 0; i < arr.length; i += size) out.push(arr.slice(i, i + size))
Â  return out
}

// Fallback utilities for general /api/wp/users queries (search, paging, etc.)
type AnyObj = Record<string, unknown>
function signProxy(method: string, path: string, body: string, secret: string) {
Â  const ts = String(Math.floor(Date.now() / 1000))
Â  const base = ${method.toUpperCase()}\n${path}\n${ts}\n${body || ''}
Â  const sig = createHmac('sha256', secret).update(base).digest('base64')
Â  return { ts, sign: sig }
}
function authHeader() {
Â  const user = process.env.WP_API_USER
Â  const appPass = process.env.WP_API_APP_PASSWORD
Â  if (!user || !appPass) return undefined
Â  const token = Buffer.from(${user}:${appPass}).toString('base64')
Â  return Basic ${token}
}
function sanitizeUser(u: AnyObj) {
Â  return {
Â  Â  id: u?.id,
Â  Â  slug: u?.slug,
Â  Â  name: u?.name ?? u?.display_name,
Â  Â  display_name: u?.display_name,
Â  Â  description: u?.description ?? '',
Â  Â  avatar_urls: u?.avatar_urls ?? {},
Â  Â  url: u?.url ?? '',
Â  Â  social: deriveSocial(u),
Â  }
}

export async function GET(req: Request) {
Â  const WP = process.env.WP_URL || process.env.NEXT_PUBLIC_WP_URL
Â  if (!WP) return new Response(JSON.stringify({ error: 'WP_URL env required' }), { status: 500 })

Â  const url = new URL(req.url)
Â  const includeParam = url.searchParams.get('include') || ''
Â  const ids = includeParam
Â  Â  .split(',')
Â  Â  .map(s => parseInt(s, 10))
Â  Â  .filter(n => Number.isFinite(n) && n > 0)

Â  // If include[] requested, serve minimal fast list
Â  if (ids.length > 0) {
Â  Â  const base = WP.replace(//$/, '')
Â  Â  const perPage = 100
Â  Â  const idChunks = chunk(ids, perPage)

Â  const results: unknown[] = []
Â  Â  await Promise.all(idChunks.map(async (group) => {
Â  Â  Â  const u = new URL('/wp-json/wp/v2/users', base)
Â  Â  Â  group.forEach(id => u.searchParams.append('include[]', String(id)))
Â  Â  Â  u.searchParams.set('per_page', String(perPage))
Â  Â  Â  u.searchParams.set('context', 'view')
Â  Â  Â  u.searchParams.set('_fields', 'id,slug,name,description,avatar_urls,social')
Â  Â  Â  const res = await fetch(u.toString(), { cache: 'no-store' })
Â  Â  Â  if (res.ok) {
Â  Â  Â  Â  const arr = await res.json().then(x => Array.isArray(x) ? x : []).catch(() => [])
Â  Â  Â  Â  results.push(...arr)
Â  Â  Â  }
Â  Â  }))

Â  const map = new Map<number, unknown>((results as Array<Record<string, unknown>>).map((u) => [Number(u.id), u]))
Â  Â  const ordered = ids.map(id => map.get(id)).filter(Boolean)
Â  Â  const out = ordered.map(sanitize)
Â  Â  return new Response(JSON.stringify(out), { status: 200, headers: { 'Content-Type': 'application/json' } })
Â  }

Â  // Otherwise, preserve existing generic behavior (search, paging, etc.)
Â  const base = WP.replace(//$/, '')
Â  const urlIn = new URL(req.url)
Â  const allowed = new Set([
Â  Â  'context', 'search', 'slug', 'page', 'per_page', 'include', 'exclude', 'orderby', 'order'
Â  ])
Â  const qEntries: [string, string][] = []
Â  urlIn.searchParams.forEach((v, k) => {
Â  Â  if (allowed.has(k)) qEntries.push([k, v])
Â  })
Â  if (!qEntries.find(([k]) => k === 'context')) qEntries.push(['context', 'view'])

Â  const secret = process.env.FE_PROXY_SECRET || ''
Â  const path = 'wp/v2/users'
Â  let upstreamTried: string | undefined
Â  if (secret) {
Â  Â  try {
Â  Â  Â  const proxy = new URL('/wp-json/fe-auth/v1/proxy', base)
Â  Â  Â  proxy.searchParams.set('path', path)
Â  Â  Â  for (const [k, v] of qEntries) proxy.searchParams.set(query[${k}], v)
Â  Â  Â  const { ts, sign } = signProxy('GET', path, '', secret)
Â  Â  Â  const pres = await fetch(proxy.toString(), { headers: { 'x-fe-ts': ts, 'x-fe-sign': sign }, cache: 'no-store' })
Â  Â  Â  upstreamTried = proxy.toString()
Â  Â  Â  if (pres.ok) {
Â  Â  Â  Â  const arr = await pres.json().catch(() => null)
Â  Â  Â  Â  const list = Array.isArray(arr) ? arr : []
Â  Â  Â  Â  return new Response(JSON.stringify(list.map(sanitizeUser)), {
Â  Â  Â  Â  Â  status: 200,
Â  Â  Â  Â  Â  headers: { 'Content-Type': 'application/json', 'X-Upstream-Url': upstreamTried }
Â  Â  Â  Â  })
Â  Â  Â  }
Â  Â  Â  if ([400, 401, 404].includes(pres.status)) {
Â  Â  Â  Â  return new Response(JSON.stringify([]), {
Â  Â  Â  Â  Â  status: 200,
Â  Â  Â  Â  Â  headers: { 'Content-Type': 'application/json', 'X-Upstream-Url': upstreamTried }
Â  Â  Â  Â  })
Â  Â  Â  }
Â  Â  } catch (_e) {
Â  Â  Â  // fall through
// TODO: implement
Â  Â  }
Â  }

Â  const direct = new URL('/wp-json/wp/v2/users', base)
Â  for (const [k, v] of qEntries) direct.searchParams.set(k, v)
Â  const headers: Record<string, string> = {}
Â  const basic = authHeader()
Â  if (basic) {
Â  Â  headers.Authorization = basic
Â  }
Â  const dres = await fetch(direct.toString(), { headers, cache: 'no-store' })
Â  upstreamTried = direct.toString()
Â  if (!dres.ok) {
Â  Â  if ([400, 401, 404].includes(dres.status)) {
Â  Â  Â  return new Response(JSON.stringify([]), {
Â  Â  Â  Â  status: 200,
Â  Â  Â  Â  headers: { 'Content-Type': 'application/json', 'X-Upstream-Url': upstreamTried }
Â  Â  Â  })
Â  Â  }
Â  Â  return new Response(JSON.stringify({ error: Upstream ${dres.status} }), { status: 502, headers: { 'X-Upstream-Url': upstreamTried! } })
Â  }
Â  const data = await dres.json().catch(() => null)
Â  const list = Array.isArray(data) ? data : []
Â  return new Response(JSON.stringify(list.map(sanitizeUser)), {
Â  Â  status: 200,
Â  Â  headers: { 'Content-Type': 'application/json', 'X-Upstream-Url': upstreamTried }
Â  })
}

// ==== FILE: app\api\wp\users\avatar\route.ts ====
import { cookies } from 'next/headers'

import { SessionClaims, verifySession } from '@/lib/jwt'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

export async function POST(req: Request) {
Â  const WP = process.env.WP_URL
Â  if (!WP) return new Response(JSON.stringify({ error: 'WP_URL env required' }), { status: 500 })

Â  const cookieStore = await cookies()
Â  const sessionCookie = cookieStore.get(process.env.SESSION_COOKIE_NAME ?? 'session')
Â  if (!sessionCookie?.value) return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401 })

Â  let claims: SessionClaims
Â  try { claims = await verifySession(sessionCookie.value) } catch { return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401 }) }
Â  const wpToken = claims?.wpToken
Â  if (!wpToken) return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401 })

Â  // Parse form-data
Â  const form = await req.formData()
Â  const file = form.get('file') as File | null
Â  if (!file) return new Response(JSON.stringify({ error: 'Missing file' }), { status: 400 })

Â  const arrayBuf = await file.arrayBuffer()
Â  const filename = file.name || 'avatar.jpg'
Â  const contentType = file.type || 'application/octet-stream'

Â  // Upload to WP Media Library
Â  const mediaUrl = new URL('/wp-json/wp/v2/media', WP)
Â  const uploadRes = await fetch(mediaUrl, {
Â  Â  method: 'POST',
Â  Â  headers: {
Â  Â  Â  Authorization: Bearer ${wpToken},
Â  Â  Â  'Content-Type': contentType,
Â  Â  Â  'Content-Disposition': attachment; filename="${filename}",
Â  Â  },
Â  Â  body: arrayBuf,
Â  })
Â  if (!uploadRes.ok) {
Â  Â  const text = await uploadRes.text().catch(() => '')
Â  Â  return new Response(JSON.stringify({ error: 'Upload failed', detail: text.slice(0, 1000) }), { status: uploadRes.status })
Â  }
Â  const media: unknown = await uploadRes.json()
Â  const mediaId = (media && typeof media === 'object' && 'id' in media) ? (media as {id: unknown}).id : null;
Â  const mediaUrlOut = (media && typeof media === 'object' && 'source_url' in media) ? (media as {source_url: unknown}).source_url : null;

Â  // Best-effort: try to set a local avatar via common plugin meta
Â  let avatarSet = false
Â  try {
Â  Â  const userPatchUrl = new URL('/wp-json/wp/v2/users/me', WP)
Â  Â  const patchRes = await fetch(userPatchUrl, {
Â  Â  Â  method: 'POST', // WP REST Users supports POST for update
Â  Â  Â  headers: {
Â  Â  Â  Â  Authorization: Bearer ${wpToken},
Â  Â  Â  Â  'Content-Type': 'application/json',
Â  Â  Â  },
Â  Â  Â  body: JSON.stringify({
Â  Â  Â  Â  meta: {
Â  Â  Â  Â  Â  // Simple Local Avatars plugin support (if registered in REST):
Â  Â  Â  Â  Â  simple_local_avatar: { media_id: mediaId },
Â  Â  Â  Â  Â  // WP User Avatar (deprecated) possible key:
Â  Â  Â  Â  Â  wp_user_avatar: mediaId,
Â  Â  Â  Â  },
Â  Â  Â  }),
Â  Â  })
Â  Â  avatarSet = patchRes.ok
Â  } catch {
Â  Â  // ignore and fall back to returning the uploaded image
// TODO: implement
Â  }

Â  return new Response(
Â  Â  JSON.stringify({ id: mediaId, url: mediaUrlOut, setInProfile: avatarSet }),
Â  Â  { status: 200, headers: { 'Content-Type': 'application/json' } }
Â  )
}

// ==== FILE: app\api\wp\users\bulk-delete\route.ts ====
import { fetchWithAuth } from '@/lib/fetchWithAuth'
import { apiMap } from '@/lib/wpAPIMap'
import { requireAccess } from '@/lib/requireAccess'

export const runtime = 'nodejs'

export async function POST(req: Request) {
Â  await requireAccess({ path: '/api/wp/users/[id]', method: 'DELETE', action: 'delete' })
Â  // Expect body: { ids: number[] }
Â  const body = await req.text()
Â  // No WP bulk endpoint by default; this is placeholder returning 501 unless MU endpoint exists.
Â  const target = apiMap.users?.bulkDelete
Â  if (!target) return new Response(JSON.stringify({ error: 'Not implemented' }), { status: 501 })
Â  return fetchWithAuth(req, target, { method: 'POST', body, headers: { 'Content-Type': 'application/json' } })
}

// ==== FILE: app\api\wp\users\count\route.ts ====
import { getWpTokenFromRequest } from '@/lib/fetchWithAuth'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

export async function GET(req: Request) {
Â  const WP = process.env.WP_URL
Â  if (!WP) return Response.json({ error: 'WP_URL env required' }, { status: 500 })
Â  const token = await getWpTokenFromRequest(req)
Â  if (!token) return Response.json({ error: 'unauthorized', message: 'Login required' }, { status: 401 })

Â  const u = new URL('/wp-json/wp/v2/users', WP)
Â  u.searchParams.set('per_page', '1')
Â  u.searchParams.set('context', 'edit')
Â  u.searchParams.set('_fields', 'id')
Â  const res = await fetch(u.toString(), { cache: 'no-store', headers: { Authorization: Bearer ${token}, Accept: 'application/json' } })
Â  const total = res.headers.get('x-wp-total')
Â  return Response.json({ count: total ? Number(total) : (res.ok ? 0 : null) }, { status: res.ok ? 200 : res.status })
}

// ==== FILE: app\api\wp\users\me\route.ts ====
import { SessionClaims, verifySession } from '@/lib/jwt'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

export async function GET(req: Request) {
Â  const WP = process.env.WP_URL
Â  if (!WP) return new Response(JSON.stringify({ error: 'config', message: 'WP_URL env required' }), { status: 500 })

Â  // Extract session token from cookie header (align with /api/auth/me)
Â  const cookieHeader = req.headers.get('cookie') || ''
Â  const match = cookieHeader.match(new RegExp(${process.env.SESSION_COOKIE_NAME || 'session'}=([^;]+)))
Â  const token = match?.[1]
Â  if (!token) return new Response(JSON.stringify({ error: 'unauthorized', message: 'Missing session cookie' }), { status: 401, headers: { 'Content-Type': 'application/json' } })

Â  let claims: SessionClaims
Â  try { claims = await verifySession(token) } catch {
Â  Â  return new Response(JSON.stringify({ error: 'unauthorized', message: 'Invalid session token' }), { status: 401, headers: { 'Content-Type': 'application/json' } })
Â  }
Â  const wpToken = claims?.wpToken
Â  if (!wpToken) return new Response(JSON.stringify({ error: 'unauthorized', message: 'Missing wpToken in session' }), { status: 401, headers: { 'Content-Type': 'application/json' } })

Â  // Include profile_fields exposed by FE Auth Bridge plugin (and meta for backward compat)
Â  const fields = 'id,slug,name,email,roles,avatar_urls,description,url,locale,nickname,profile_fields,meta'
Â  // Try MU plugin proxy first
Â  const proxyUrl = new URL('/wp-json/fe-auth/v1/proxy', WP)
Â  proxyUrl.searchParams.set('path', 'wp/v2/users/me')
Â  proxyUrl.searchParams.set('context', 'edit')
Â  proxyUrl.searchParams.set('_fields', fields)
Â  let res = await fetch(proxyUrl, {
Â  Â  headers: {
Â  Â  Â  Authorization: Bearer ${wpToken},
Â  Â  Â  // Some proxies read cookies; pass token also as cookie for compatibility
Â  Â  Â  Cookie: Authorization=Bearer ${wpToken},
Â  Â  },
Â  Â  cache: 'no-store',
Â  })
Â  if (!res.ok) {
Â  Â  // Fallback to direct WP REST
Â  Â  const url = new URL('/wp-json/wp/v2/users/me', WP)
Â  Â  url.searchParams.set('context', 'edit')
Â  Â  url.searchParams.set('_fields', fields)
Â  Â  res = await fetch(url, { headers: { Authorization: Bearer ${wpToken} }, cache: 'no-store' })
Â  }
Â  const text = await res